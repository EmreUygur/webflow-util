{
  "version": 3,
  "sources": ["../src/webflow-core/debug.ts", "../src/webflow-core.ts", "../src/webflow-data/webflow-collectionlist-data.ts", "../src/modules/webflow-data-csv.js", "../src/modules/webflow-html.js", "../src/modules/webflow-data.js", "../src/webflow-data/google-sheet-data.ts", "../src/webflow-data/database.ts", "../src/webflow-data/sa5-data.ts", "../src/webflow-data.ts"],
  "sourcesContent": ["\n/*\n * webflow-core\n * \n * Sygnal Technology Group\n * http://sygnal.com\n * \n * Debug Utilities\n */\n\n\n\nexport class Sa5Debug {\n    \n    private localStorageDebugFlag: string = 'sa5-debug';\n\n    private _enabled: boolean = false;\n    private _label: string;\n\n    // Get or set WFU persistent debug state\n    // which is stored in localStorage. \n    get persistentDebug(): boolean {\n        return Boolean(localStorage.getItem(this.localStorageDebugFlag)); \n    }\n    set persistentDebug(active: boolean) {\n        if (active) {\n            localStorage.setItem(this.localStorageDebugFlag, \"true\");\n            console.debug (\"sa5-core debug enabled (persistent).\");\n        } else {\n            localStorage.removeItem(this.localStorageDebugFlag); \n            console.debug (\"sa5-core debug disabled (persistent).\");\n        }\n    }\n\n    // Enable/disable debugging \n    get enabled(): boolean {\n\n        // localStorage is checked for a debug flag, to enable remote debug enabling \n        // Any non-null string value will resolve to TRUE here, including the string \"false\" \n        var wfuDebugValue = Boolean(localStorage.getItem(this.localStorageDebugFlag)); \n\n        // Or this with the current debug state\n        // If either is enabled, debugging is on \n        wfuDebugValue = wfuDebugValue || this._enabled; \n\n        return wfuDebugValue;\n    }\n    set enabled(active: boolean) {\n        this._enabled = active;\n    }\n\n\n    // Initialize\n    constructor(label: string) {\n\n        // Save the label, for console logging\n        this._label = label;\n\n    }\n\n\n    // Start a console log group\n    group(name) {\n        if (this.enabled)\n            console.group(name);\n    }\n\n    // End a console log group\n    groupEnd() {\n        if (this.enabled)\n            console.groupEnd();\n    }\n\n    // Log debug data to the console\n    debug(...args: any[]): void {\n\n        if (this.enabled)\n            // Unlimited arguments in a JavaScript function\n            // https://stackoverflow.com/a/6396066\n            console.debug(this._label, ...args); \n            \n    }\n\n}\n\n\n", "\n/*\n * webflow-core\n * \n * Sygnal Technology Group\n * http://sygnal.com\n * \n * Core Utilities\n */\n\n\n\n// export interface Sa5Handler {\n//     [0]: string;\n//     [1]: Function;\n// }\n\n\n// import { HtmlBuilder } from './modules/webflow-html-builder';\nimport { Sa5Debug } from './webflow-core/debug'\n\n/*\n * Debugging class.\n */\n\nexport class Sa5Core {\n\n    // let sa5: [string, Function][] = window.sa5 || [];\n    public handlers = [];\n\n    getHandlers(name: string): Function[] {\n\n        return this.handlers.filter(item => item[0] === name)\n            .map(item => item[1]);\n\n//        return null;\n    }\n\n    getHandler(name: string): Function | undefined {\n        const item = this.handlers\n            .find(item => item[0] === name);\n        return item ? item[1] : undefined;\n    }\n\n    // Map for elements wired to Sa5 objects \n//    public elements: WeakMap<HTMLElement, object>;\n//     map.set(elem, myObject);\n\n// // Later, you can retrieve the object like this\n// let retrievedObject = map.get(elem);\n\n    constructor() {\n//        this.elements = new WeakMap<HTMLElement, object>();\n    }\n\n    init() {\n\n        this.initDebugMode();\n\n    }\n\n    // Auto-enable debug\n    // based on ?sa-debug=true querystring param\n    initDebugMode() {\n\n        const debugParamKey = 'debug'; // ?sa-debug=true\n\n//        var wfuDebugValue = Boolean(localStorage.setItem('wfuDebug', 'true')); \n\n        let params = new URLSearchParams(window.location.search);\n        let hasDebug = params.has(debugParamKey);\n\n        if (hasDebug) {\n            let wfuDebug = new Sa5Debug(`sa5 init`);\n            wfuDebug.persistentDebug = this.stringToBoolean(params.get(debugParamKey));\n        }\n\n    }\n\n    stringToBoolean(str: string): boolean {\n        const truthyValues: string[] = ['1', 'true', 'yes'];\n        const falsyValues: string[] = ['0', 'false', 'no'];\n      \n        if (truthyValues.indexOf(str.toLowerCase()) !== -1) {\n            return true;\n        // } else if (falsyValues.indexOf(str.toLowerCase()) !== -1) {\n        //     return false;\n        } else {\n            return false;\n        }\n    }\n\n    // Factory \n    // Get or create Sa5Core \n    static startup(module: any | null = null): Sa5Core {\n\n//        console.debug(\"sa5core\", \"startup\");\n\n//        console.debug(\"INITIALIZING SA5CORE\");\n//        console.log(window[\"sa5\"]);\n        \n        let sa5instance = window['sa5'];\n\n        var core: Sa5Core; // = new Sa5Core();\n\n        // Initialize Sa5Core if needed\n\n        if(sa5instance?.constructor?.name == \"Sa5Core\") {\n\n            core = sa5instance;\n\n        } else {\n\n    //         if(window[\"sa5\"])\n    // console.log(\"name\", window[\"sa5\"].name);\n\n            core = new Sa5Core();\n\n            // Absorb handlers\n            if(Array.isArray(sa5instance))\n                core.handlers = sa5instance; //window[\"sa5\"];\n\n            window[\"sa5\"] = core;\n            window[\"Sa5\"] = window[\"sa5\"];\n//            console.log(\"post\", window[\"sa5\"] instanceof Sa5Core);\n\n        } \n\n        // Add new module\n        //window[\"sa5\"] = window[\"sa5\"] || []; // {};\n        if (module) {\n\n//            console.debug(\"Registered module\", module.name); \n\n            window[\"sa5\"][module.name] = module;\n//            console.log(window[\"sa5\"][module.name]);\n        }\n\n        // instance.constructor.name\n\n        return core;\n    }\n\n    // Add new handlers\n    push(o) {\n        this.handlers.push(o);\n    }\n\n}\n\n\n// Complete initialization \n// even though we don't need it yet \nSa5Core.startup(); \n\n\n// Register\n//window[\"sa5\"] = window[\"sa5\"] || []; // {};\n//window[\"sa5\"][\"Sa5Core\"] = Sa5Core;\n", "\n/*\n * Sygnal Technology Group\n * http://sygnal.com\n * \n * Creates a data source from a Webflow Collection list.\n */\n\n// import { Database } from '../modules/webflow-data.js';\n\n\nexport const prepareCollectionListDataSource = (dataSource: Element) => {\n    // Aggregate JSON Data\n    let data = dataSource.querySelectorAll('script');\n    console.log(`items = ${data.length}`);\n\n    let items: string[] = []; // place to store the pairs\n    data.forEach((elem) => { //loop over the keys\n        items.push(elem.textContent || \"\");\n    })\n\n    let json = '[' + items.join() + ']';\n\n    return JSON.parse(json);\n}\n\n\n", "\n// Sygnal Technology Group\n// http://sygnal.com\n\n/* ESM adapted from\n * jQuery-csv (jQuery Plugin) by Evan Plaice\n * \n * - jQuery use removed\n * - redesigned as an ESM\n * \n * Original jQuery source notices;\n *\n * This document is licensed as free software under the terms of the\n * MIT License: http://www.opensource.org/licenses/mit-license.php\n *\n * Acknowledgements:\n * The original design and influence to implement this library as a jquery\n * plugin is influenced by jquery-json (http://code.google.com/p/jquery-json/).\n * If you're looking to use native JSON.Stringify but want additional backwards\n * compatibility for browsers that don't support it, I highly recommend you\n * check it out.\n *\n * A special thanks goes out to rwk@acm.org for providing a lot of valuable\n * feedback to the project including the core for the new FSM\n * (Finite State Machine) parsers. If you're looking for a stable TSV parser\n * be sure to take a look at jquery-tsv (http://code.google.com/p/jquery-tsv/).\n\n * For legal purposes I'll include the \"NO WARRANTY EXPRESSED OR IMPLIED.\n * USE AT YOUR OWN RISK.\". Which, in 'layman's terms' means, by using this\n * library you are accepting responsibility if it breaks your code.\n *\n * Original jQuery version copyrighted 2012 by Evan Plaice.\n */\n\nRegExp.escape = function (s) {\n    return s.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n};\n\nvar defaults = {\n    separator: ',',\n    delimiter: '\"',\n    headers: true\n};\n\nvar castToScalar = function (value, state) {\n    const hasDot = /\\./\n    if (isNaN(value)) {\n        return value\n    } else {\n        if (hasDot.test(value)) {\n            return parseFloat(value)\n        } else {\n            const integer = parseInt(value)\n            if (isNaN(integer)) {\n                return null\n            } else {\n                return integer\n            }\n        }\n    }\n}\n\nvar parse = function (csv, options) {\n    // cache settings\n    const separator = options.separator\n    const delimiter = options.delimiter\n\n    // set initial state if it's missing\n    if (!options.state.rowNum) {\n        options.state.rowNum = 1\n    }\n    if (!options.state.colNum) {\n        options.state.colNum = 1\n    }\n\n    // clear initial state\n    const data = []\n    let entry = []\n    let state = 0\n    let value = ''\n    let exit = false\n\n    function endOfEntry() {\n        // reset the state\n        state = 0\n        value = ''\n\n        // if 'start' hasn't been met, don't output\n        if (options.start && options.state.rowNum < options.start) {\n            // update global state\n            entry = []\n            options.state.rowNum++\n            options.state.colNum = 1\n            return\n        }\n\n        if (options.onParseEntry === undefined) {\n            // onParseEntry hook not set\n            data.push(entry)\n        } else {\n            const hookVal = options.onParseEntry(entry, options.state) // onParseEntry Hook\n            // false skips the row, configurable through a hook\n            if (hookVal !== false) {\n                data.push(hookVal)\n            }\n        }\n        // console.log('entry:' + entry);\n\n        // cleanup\n        entry = []\n\n        // if 'end' is met, stop parsing\n        if (options.end && options.state.rowNum >= options.end) {\n            exit = true\n        }\n\n        // update global state\n        options.state.rowNum++\n        options.state.colNum = 1\n    }\n\n    function endOfValue() {\n        if (options.onParseValue === undefined) {\n            // onParseValue hook not set\n            entry.push(value)\n        } else if (options.headers && options.state.rowNum === 1) {\n            // don't onParseValue object headers\n            entry.push(value)\n        } else {\n            const hook = options.onParseValue(value, options.state) // onParseValue Hook\n            // false skips the row, configurable through a hook\n            if (hook !== false) {\n                entry.push(hook)\n            }\n        }\n        // console.log('value:' + value);\n        // reset the state\n        value = ''\n        state = 0\n        // update global state\n        options.state.colNum++\n    }\n\n    // escape regex-specific control chars\n    const escSeparator = RegExp.escape(separator)\n    const escDelimiter = RegExp.escape(delimiter)\n\n    // compile the regEx str using the custom delimiter/separator\n    let match = /(D|S|\\r\\n|\\n|\\r|[^DS\\r\\n]+)/\n    let matchSrc = match.source\n    matchSrc = matchSrc.replace(/S/g, escSeparator)\n    matchSrc = matchSrc.replace(/D/g, escDelimiter)\n    match = new RegExp(matchSrc, 'gm')\n\n    // put on your fancy pants...\n    // process control chars individually, use look-ahead on non-control chars\n    csv.replace(match, function (m0) {\n        if (exit) {\n            return\n        }\n        switch (state) {\n            // the start of a value\n            case 0:\n                // null last value\n                if (m0 === separator) {\n                    value += ''\n                    endOfValue()\n                    break\n                }\n                // opening delimiter\n                if (m0 === delimiter) {\n                    state = 1\n                    break\n                }\n                // null last value\n                if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                    endOfValue()\n                    endOfEntry()\n                    break\n                }\n                // un-delimited value\n                value += m0\n                state = 3\n                break\n\n            // delimited input\n            case 1:\n                // second delimiter? check further\n                if (m0 === delimiter) {\n                    state = 2\n                    break\n                }\n                // delimited data\n                value += m0\n                state = 1\n                break\n\n            // delimiter found in delimited input\n            case 2:\n                // escaped delimiter?\n                if (m0 === delimiter) {\n                    value += m0\n                    state = 1\n                    break\n                }\n                // null value\n                if (m0 === separator) {\n                    endOfValue()\n                    break\n                }\n                // end of entry\n                if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                    endOfValue()\n                    endOfEntry()\n                    break\n                }\n                // broken paser?\n                throw Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n\n            // un-delimited input\n            case 3:\n                // null last value\n                if (m0 === separator) {\n                    endOfValue()\n                    break\n                }\n                // end of entry\n                if (/^(\\r\\n|\\n|\\r)$/.test(m0)) {\n                    endOfValue()\n                    endOfEntry()\n                    break\n                }\n                if (m0 === delimiter) {\n                    // non-compliant data\n                    throw Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n                }\n                // broken parser?\n                throw Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n            default:\n                // shenanigans\n                throw Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n        }\n        // console.log('val:' + m0 + ' state:' + state);\n    })\n\n    // submit the last entry\n    // ignore null last line\n    if (entry.length !== 0) {\n        endOfValue()\n        endOfEntry()\n    }\n\n    return data\n}\n\n// a csv-specific line splitter\nvar splitLines = function (csv, options) {\n    if (!csv) {\n        return undefined\n    }\n\n    options = options || {}\n\n    // cache settings\n    const separator = options.separator || $.csv.defaults.separator\n    const delimiter = options.delimiter || $.csv.defaults.delimiter\n\n    // set initial state if it's missing\n    options.state = options.state || {}\n    if (!options.state.rowNum) {\n        options.state.rowNum = 1\n    }\n\n    // clear initial state\n    const entries = []\n    let state = 0\n    let entry = ''\n    let exit = false\n\n    function endOfLine() {\n        // reset the state\n        state = 0\n\n        // if 'start' hasn't been met, don't output\n        if (options.start && options.state.rowNum < options.start) {\n            // update global state\n            entry = ''\n            options.state.rowNum++\n            return\n        }\n\n        if (options.onParseEntry === undefined) {\n            // onParseEntry hook not set\n            entries.push(entry)\n        } else {\n            const hookVal = options.onParseEntry(entry, options.state) // onParseEntry Hook\n            // false skips the row, configurable through a hook\n            if (hookVal !== false) {\n                entries.push(hookVal)\n            }\n        }\n\n        // cleanup\n        entry = ''\n\n        // if 'end' is met, stop parsing\n        if (options.end && options.state.rowNum >= options.end) {\n            exit = true\n        }\n\n        // update global state\n        options.state.rowNum++\n    }\n\n    // escape regex-specific control chars\n    const escSeparator = RegExp.escape(separator)\n    const escDelimiter = RegExp.escape(delimiter)\n\n    // compile the regEx str using the custom delimiter/separator\n    let match = /(D|S|\\n|\\r|[^DS\\r\\n]+)/\n    let matchSrc = match.source\n    matchSrc = matchSrc.replace(/S/g, escSeparator)\n    matchSrc = matchSrc.replace(/D/g, escDelimiter)\n    match = new RegExp(matchSrc, 'gm')\n\n    // put on your fancy pants...\n    // process control chars individually, use look-ahead on non-control chars\n    csv.replace(match, function (m0) {\n        if (exit) {\n            return\n        }\n        switch (state) {\n            // the start of a value/entry\n            case 0:\n                // null value\n                if (m0 === separator) {\n                    entry += m0\n                    state = 0\n                    break\n                }\n                // opening delimiter\n                if (m0 === delimiter) {\n                    entry += m0\n                    state = 1\n                    break\n                }\n                // end of line\n                if (m0 === '\\n') {\n                    endOfLine()\n                    break\n                }\n                // phantom carriage return\n                if (/^\\r$/.test(m0)) {\n                    break\n                }\n                // un-delimit value\n                entry += m0\n                state = 3\n                break\n\n            // delimited input\n            case 1:\n                // second delimiter? check further\n                if (m0 === delimiter) {\n                    entry += m0\n                    state = 2\n                    break\n                }\n                // delimited data\n                entry += m0\n                state = 1\n                break\n\n            // delimiter found in delimited input\n            case 2: {\n                // escaped delimiter?\n                const prevChar = entry.substr(entry.length - 1)\n                if (m0 === delimiter && prevChar === delimiter) {\n                    entry += m0\n                    state = 1\n                    break\n                }\n                // end of value\n                if (m0 === separator) {\n                    entry += m0\n                    state = 0\n                    break\n                }\n                // end of line\n                if (m0 === '\\n') {\n                    endOfLine()\n                    break\n                }\n                // phantom carriage return\n                if (m0 === '\\r') {\n                    break\n                }\n                // broken paser?\n                throw Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']')\n            }\n            // un-delimited input\n            case 3:\n                // null value\n                if (m0 === separator) {\n                    entry += m0\n                    state = 0\n                    break\n                }\n                // end of line\n                if (m0 === '\\n') {\n                    endOfLine()\n                    break\n                }\n                // phantom carriage return\n                if (m0 === '\\r') {\n                    break\n                }\n                // non-compliant data\n                if (m0 === delimiter) {\n                    throw Error('CSVDataError: Illegal quote [Row:' + options.state.rowNum + ']')\n                }\n                // broken parser?\n                throw Error('CSVDataError: Illegal state [Row:' + options.state.rowNum + ']')\n            default:\n                // shenanigans\n                throw Error('CSVDataError: Unknown state [Row:' + options.state.rowNum + ']')\n        }\n        // console.log('val:' + m0 + ' state:' + state);\n    })\n\n    // submit the last entry\n    // ignore null last line\n    if (entry !== '') {\n        endOfLine()\n    }\n\n    return entries\n}\n\n// a csv entry parser\nvar parseEntry = function (csv, options) {\n    // cache settings\n    const separator = options.separator\n    const delimiter = options.delimiter\n\n    // set initial state if it's missing\n    if (!options.state.rowNum) {\n        options.state.rowNum = 1\n    }\n    if (!options.state.colNum) {\n        options.state.colNum = 1\n    }\n\n    // clear initial state\n    const entry = []\n    let state = 0\n    let value = ''\n\n    function endOfValue() {\n        if (options.onParseValue === undefined) {\n            // onParseValue hook not set\n            entry.push(value)\n        } else {\n            const hook = options.onParseValue(value, options.state) // onParseValue Hook\n            // false skips the value, configurable through a hook\n            if (hook !== false) {\n                entry.push(hook)\n            }\n        }\n        // reset the state\n        value = ''\n        state = 0\n        // update global state\n        options.state.colNum++\n    }\n\n    // checked for a cached regEx first\n    if (!options.match) {\n        // escape regex-specific control chars\n        const escSeparator = RegExp.escape(separator)\n        const escDelimiter = RegExp.escape(delimiter)\n\n        // compile the regEx str using the custom delimiter/separator\n        const match = /(D|S|\\n|\\r|[^DS\\r\\n]+)/\n        let matchSrc = match.source\n        matchSrc = matchSrc.replace(/S/g, escSeparator)\n        matchSrc = matchSrc.replace(/D/g, escDelimiter)\n        options.match = new RegExp(matchSrc, 'gm')\n    }\n\n    // put on your fancy pants...\n    // process control chars individually, use look-ahead on non-control chars\n    csv.replace(options.match, function (m0) {\n        switch (state) {\n            // the start of a value\n            case 0:\n                // null last value\n                if (m0 === separator) {\n                    value += ''\n                    endOfValue()\n                    break\n                }\n                // opening delimiter\n                if (m0 === delimiter) {\n                    state = 1\n                    break\n                }\n                // skip un-delimited new-lines\n                if (m0 === '\\n' || m0 === '\\r') {\n                    break\n                }\n                // un-delimited value\n                value += m0\n                state = 3\n                break\n\n            // delimited input\n            case 1:\n                // second delimiter? check further\n                if (m0 === delimiter) {\n                    state = 2\n                    break\n                }\n                // delimited data\n                value += m0\n                state = 1\n                break\n\n            // delimiter found in delimited input\n            case 2:\n                // escaped delimiter?\n                if (m0 === delimiter) {\n                    value += m0\n                    state = 1\n                    break\n                }\n                // null value\n                if (m0 === separator) {\n                    endOfValue()\n                    break\n                }\n                // skip un-delimited new-lines\n                if (m0 === '\\n' || m0 === '\\r') {\n                    break\n                }\n                // broken paser?\n                throw Error('CSVDataError: Illegal State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n\n            // un-delimited input\n            case 3:\n                // null last value\n                if (m0 === separator) {\n                    endOfValue()\n                    break\n                }\n                // skip un-delimited new-lines\n                if (m0 === '\\n' || m0 === '\\r') {\n                    break\n                }\n                // non-compliant data\n                if (m0 === delimiter) {\n                    throw Error('CSVDataError: Illegal Quote [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n                }\n                // broken parser?\n                throw Error('CSVDataError: Illegal Data [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n            default:\n                // shenanigans\n                throw Error('CSVDataError: Unknown State [Row:' + options.state.rowNum + '][Col:' + options.state.colNum + ']')\n        }\n        // console.log('val:' + m0 + ' state:' + state);\n    })\n\n    // submit the last value\n    endOfValue()\n\n    return entry\n}\n\n/**\n* $.csv.helpers.collectPropertyNames(objectsArray)\n* Collects all unique property names from all passed objects.\n*\n* @param {Array} objects Objects to collect properties from.\n*\n* Returns an array of property names (array will be empty,\n* if objects have no own properties).\n*/\nvar collectPropertyNames = function (objects) {\n    let o = []\n    let propName = []\n    const props = []\n    for (o in objects) {\n        for (propName in objects[o]) {\n            if ((objects[o].hasOwnProperty(propName)) &&\n                (props.indexOf(propName) < 0) &&\n                (typeof objects[o][propName] !== 'function')) {\n                props.push(propName)\n            }\n        }\n    }\n    return props\n}\n\n/**\n* $.csv.toArray(csv)\n* Converts a CSV entry string to a javascript array.\n*\n* @param {Array} csv The string containing the CSV data.\n* @param {Object} [options] An object containing user-defined options.\n* @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n* @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n*\n* This method deals with simple CSV strings only. It's useful if you only\n* need to parse a single entry. If you need to parse more than one line,\n* use $.csv2Array instead.\n*/\nvar toArray = function (csv, options, callback) {\n    // if callback was passed to options swap callback with options\n    if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n            return console.error('You cannot 3 arguments with the 2nd argument being a function')\n        }\n        callback = options\n        options = {}\n    }\n\n    options = (options !== undefined ? options : {})\n    const config = {}\n    config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false)\n    config.separator = 'separator' in options ? options.separator : defaults.separator\n    config.delimiter = 'delimiter' in options ? options.delimiter : defaults.delimiter\n    const state = (options.state !== undefined ? options.state : {})\n\n    // setup\n    options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        state: state\n    }\n\n    const entry = parseEntry(csv, options)\n\n    // push the value to a callback if one is defined\n    if (!config.callback) {\n        return entry\n    } else {\n        config.callback('', entry)\n    }\n}\n\n/**\n* $.csv.toArrays(csv)\n* Converts a CSV string to a javascript array.\n*\n* @param {String} csv The string containing the raw CSV data.\n* @param {Object} [options] An object containing user-defined options.\n* @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n* @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n*\n* This method deals with multi-line CSV. The breakdown is simple. The first\n* dimension of the array represents the line (or entry/row) while the second\n* dimension contains the values (or values/columns).\n*/\nvar toArrays = function (csv, options, callback) {\n    // if callback was passed to options swap callback with options\n    if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n            return console.error('You cannot 3 arguments with the 2nd argument being a function')\n        }\n        callback = options\n        options = {}\n    }\n\n    options = (options !== undefined ? options : {})\n    const config = {}\n    config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false)\n    config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator\n    config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter\n\n    // setup\n    let data = []\n    options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onPreParse: options.onPreParse,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        onPostParse: options.onPostParse,\n        start: options.start,\n        end: options.end,\n        state: {\n            rowNum: 1,\n            colNum: 1\n        }\n    }\n\n    // onPreParse hook\n    if (options.onPreParse !== undefined) {\n        csv = options.onPreParse(csv, options.state)\n    }\n\n    // parse the data\n    data = $.csv.parsers.parse(csv, options)\n\n    // onPostParse hook\n    if (options.onPostParse !== undefined) {\n        data = options.onPostParse(data, options.state)\n    }\n\n    // push the value to a callback if one is defined\n    if (!config.callback) {\n        return data\n    } else {\n        config.callback('', data)\n    }\n}\n\n/**\n* $.csv.toObjects(csv)\n* Converts a CSV string to a javascript object.\n* @param {String} csv The string containing the raw CSV data.\n* @param {Object} [options] An object containing user-defined options.\n* @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n* @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n* @param {Boolean} [headers] Indicates whether the data contains a header line. Defaults to true.\n*\n* This method deals with multi-line CSV strings. Where the headers line is\n* used as the key for each value per entry.\n*/\nexport var csvToObjects = function (csv, options, callback) {\n    // if callback was passed to options swap callback with options\n    if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n            return console.error('You cannot 3 arguments with the 2nd argument being a function')\n        }\n        callback = options\n        options = {}\n    }\n\n    options = (options !== undefined ? options : {})\n    const config = {}\n    config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false)\n    config.separator = 'separator' in options ? options.separator : defaults.separator\n    config.delimiter = 'delimiter' in options ? options.delimiter : defaults.delimiter\n    config.headers = 'headers' in options ? options.headers : defaults.headers\n    options.start = 'start' in options ? options.start : 1\n\n    // account for headers\n    if (config.headers) {\n        options.start++\n    }\n    if (options.end && config.headers) {\n        options.end++\n    }\n\n    // setup\n    let lines = []\n    let data = []\n\n    options = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        onPreParse: options.onPreParse,\n        onParseEntry: options.onParseEntry,\n        onParseValue: options.onParseValue,\n        onPostParse: options.onPostParse,\n        start: options.start,\n        end: options.end,\n        state: {\n            rowNum: 1,\n            colNum: 1\n        },\n        match: false,\n        transform: options.transform\n    }\n\n    // fetch the headers\n    const headerOptions = {\n        delimiter: config.delimiter,\n        separator: config.separator,\n        start: 1,\n        end: 1,\n        state: {\n            rowNum: 1,\n            colNum: 1\n        },\n        headers: true\n    }\n\n    // onPreParse hook\n    if (options.onPreParse !== undefined) {\n        csv = options.onPreParse(csv, options.state)\n    }\n\n    // parse the csv\n    const headerLine = splitLines(csv, headerOptions)\n    const headers = toArray(headerLine[0], headerOptions)\n\n    // fetch the data\n    lines = splitLines(csv, options)\n\n    // reset the state for re-use\n    options.state.colNum = 1\n    if (headers) {\n        options.state.rowNum = 2\n    } else {\n        options.state.rowNum = 1\n    }\n\n    // convert data to objects\n    for (let i = 0, len = lines.length; i < len; i++) {\n        const entry = toArray(lines[i], options)\n        const object = {}\n        for (let j = 0; j < headers.length; j++) {\n            object[headers[j]] = entry[j]\n        }\n        if (options.transform !== undefined) {\n            data.push(options.transform.call(undefined, object))\n        } else {\n            data.push(object)\n        }\n\n        // update row state\n        options.state.rowNum++\n    }\n\n    // onPostParse hook\n    if (options.onPostParse !== undefined) {\n        data = options.onPostParse(data, options.state)\n    }\n\n    // push the value to a callback if one is defined\n    if (!config.callback) {\n        return data\n    } else {\n        config.callback('', data)\n    }\n};\n\n/**\n* $.csv.fromArrays(arrays)\n* Converts a javascript array to a CSV String.\n*\n* @param {Array} arrays An array containing an array of CSV entries.\n* @param {Object} [options] An object containing user-defined options.\n* @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n* @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n*\n* This method generates a CSV file from an array of arrays (representing entries).\n*/\nvar fromArrays = function (arrays, options, callback) {\n    // if callback was passed to options swap callback with options\n    if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n            return console.error('You cannot 3 arguments with the 2nd argument being a function')\n        }\n        callback = options\n        options = {}\n    }\n\n    options = (options !== undefined ? options : {})\n    const config = {}\n    config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false)\n    config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator\n    config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter\n\n    let output = ''\n\n    for (let i = 0; i < arrays.length; i++) {\n        const line = arrays[i]\n        const lineValues = []\n        for (let j = 0; j < line.length; j++) {\n            let strValue = (line[j] === undefined || line[j] === null) ? '' : line[j].toString()\n            if (strValue.indexOf(config.delimiter) > -1) {\n                strValue = strValue.replace(new RegExp(config.delimiter, 'g'), config.delimiter + config.delimiter)\n            }\n\n            let escMatcher = '\\n|\\r|S|D'\n            escMatcher = escMatcher.replace('S', config.separator)\n            escMatcher = escMatcher.replace('D', config.delimiter)\n\n            if (strValue.search(escMatcher) > -1) {\n                strValue = config.delimiter + strValue + config.delimiter\n            }\n            lineValues.push(strValue)\n        }\n        output += lineValues.join(config.separator) + '\\n'\n    }\n\n    // push the value to a callback if one is defined\n    if (!config.callback) {\n        return output\n    } else {\n        config.callback('', output)\n    }\n}\n\n/**\n* $.csv.fromObjects(objects)\n* Converts a javascript dictionary to a CSV string.\n*\n* @param {Object} objects An array of objects containing the data.\n* @param {Object} [options] An object containing user-defined options.\n* @param {Character} [separator] An override for the separator character. Defaults to a comma(,).\n* @param {Character} [delimiter] An override for the delimiter character. Defaults to a double-quote(\").\n* @param {Character} [sortOrder] Sort order of columns (named after\n*   object properties). Use 'alpha' for alphabetic. Default is 'declare',\n*   which means, that properties will _probably_ appear in order they were\n*   declared for the object. But without any guarantee.\n* @param {Character or Array} [manualOrder] Manually order columns. May be\n* a strin in a same csv format as an output or an array of header names\n* (array items won't be parsed). All the properties, not present in\n* `manualOrder` will be appended to the end in accordance with `sortOrder`\n* option. So the `manualOrder` always takes preference, if present.\n*\n* This method generates a CSV file from an array of objects (name:value pairs).\n* It starts by detecting the headers and adding them as the first line of\n* the CSV file, followed by a structured dump of the data.\n*/\n\nvar fromObjects = function (objects, options, callback) {\n\n    // if callback was passed to options swap callback with options\n    if (options !== undefined && typeof (options) === 'function') {\n        if (callback !== undefined) {\n            return console.error('You cannot 3 arguments with the 2nd argument being a function')\n        }\n        callback = options\n        options = {}\n    }\n\n    options = (options !== undefined ? options : {})\n    const config = {}\n    config.callback = ((callback !== undefined && typeof (callback) === 'function') ? callback : false)\n    config.separator = 'separator' in options ? options.separator : $.csv.defaults.separator\n    config.delimiter = 'delimiter' in options ? options.delimiter : $.csv.defaults.delimiter\n    config.headers = 'headers' in options ? options.headers : $.csv.defaults.headers\n    config.sortOrder = 'sortOrder' in options ? options.sortOrder : 'declare'\n    config.manualOrder = 'manualOrder' in options ? options.manualOrder : []\n    config.transform = options.transform\n\n    if (typeof config.manualOrder === 'string') {\n        config.manualOrder = $.csv.toArray(config.manualOrder, config)\n    }\n\n    if (config.transform !== undefined) {\n        const origObjects = objects\n        objects = []\n\n        for (let i = 0; i < origObjects.length; i++) {\n            objects.push(config.transform.call(undefined, origObjects[i]))\n        }\n    }\n\n    let props = $.csv.helpers.collectPropertyNames(objects)\n\n    if (config.sortOrder === 'alpha') {\n        props.sort()\n    }\n\n    if (config.manualOrder.length > 0) {\n        const propsManual = [].concat(config.manualOrder)\n\n        for (let p = 0; p < props.length; p++) {\n            if (propsManual.indexOf(props[p]) < 0) {\n                propsManual.push(props[p])\n            }\n        }\n        props = propsManual\n    }\n\n    let line\n    const output = []\n    let propName\n    if (config.headers) {\n        output.push(props)\n    }\n\n    for (let o = 0; o < objects.length; o++) {\n        line = []\n        for (let p = 0; p < props.length; p++) {\n            propName = props[p]\n            if (propName in objects[o] && typeof objects[o][propName] !== 'function') {\n                line.push(objects[o][propName])\n            } else {\n                line.push('')\n            }\n        }\n        output.push(line)\n    }\n\n    // push the value to a callback if one is defined\n    return fromArrays(output, options, config.callback)\n}\n\n", "\n/*\n * webflow-html\n * \n * Sygnal Technology Group\n * http://sygnal.com\n * \n * HTML Utilities\n */\n\n//#region Utility functions\n\n// Credit James Padolsey \n// https://css-tricks.com/snippets/jquery/shuffle-dom-elements/\n// migrated to utils.ts\n(function($){\n \n    $.fn.shuffle = function() {\n \n        var allElems = this.get(),\n            getRandom = function(max) {\n                return Math.floor(Math.random() * max);\n            },\n            shuffled = $.map(allElems, function(){\n                var random = getRandom(allElems.length),\n                    randEl = $(allElems[random]).clone(true)[0];\n                allElems.splice(random, 1);\n                return randEl;\n           });\n \n        this.each(function(i){\n            $(this).replaceWith($(shuffled[i]));\n        });\n \n        return $(shuffled);\n \n    };\n \n})(jQuery);\n\n// HTML Decode\n// https://tertiumnon.medium.com/js-how-to-decode-html-entities-8ea807a140e5\n// MIGRATED to utils.ts\nexport var decodeHtml = function (text) {\n    \n    console.log(text);\n\n    var decoded = $(\"<textarea/>\")\n      .html(text)\n      .text();\n\nconsole.log(decoded);\n\n      return decoded;\n}\n\n// HTML Encode\n// https://tertiumnon.medium.com/js-how-to-decode-html-entities-8ea807a140e5\n//export var encodeHTML = function (text) {\n//    return $(\"<textarea/>\")\n//      .text(text)\n//      .html();\n//}\n\n\n// Simplest-case encoding for HTML5\n// MIGRATED to utils.ts\nexport var encodeHtml = function (text) {\n\n    // Important- this approach handles common scenarios,\n    // but does not handle quotes or special accented characters.\n    // See https://www.php.net/htmlspecialchars\n\n    return text\n        .replace(/&/g, \"&amp;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\");\n}\n\n//#endregion\n\n//#region IFRAMES\n\n// MIGRATED to utils.ts\nexport var autosizeIFrames = function () {\n\n    // Identify all IFRAMES with autosize tag\n    let iframes = $(\"iframe[wfu='html.iframe.autofit']\");\n\n    iframes.each(function (index) {\n\n        var iframe = this;\n\n        // Add event listener and wait for content to load\n        this.addEventListener('load', function () {\n            setInterval(function () {\n                iframe.style.height = iframe.contentDocument.body.scrollHeight + 'px';\n            }, 200);\n        });\n\n    });\n\n}\n\n//#endregion\n\n//#region Dynamic Attributes\n\n// Applies custom attributes to HTML elements throughout the page\n// from relatively-positioned <data> elements.\n// MIGRATED to utils.ts\nexport var applyDynamicAttributes = function () {\n\n    // Find all <data> elements which specify a data-source\n    // for data binding\n    var dynamicAttributeDatas = $('data[wfu-attr]');\n\n    // Iterate and bind each individually\n    $.each(dynamicAttributeDatas, function (i, elem) {\n\n        var data = this;\n\n        // Webflow wraps EMBEDS in a DIV, so we work from that parent as a positional reference\n        var dataContainer = $(data).parent();\n\n        // hide this node\n        $(dataContainer).attr(\"style\", \"display: none;\");\n\n        var target = null;\n\n        // Webflow wraps EMBEDS in a DIV[wf-embed], so we work from that parent as a reference\n        switch ($(data).attr(\"wfu-attr-target\")) {\n            case \"prev\":\n                target = $(dataContainer).prev();\n                break;\n            case \"next\":\n                target = $(dataContainer).next();\n                break;\n            case \"parent\":\n                target = $(dataContainer).parent();\n                break;\n            default:\n\n                if (vars.logging)\n                    console.warn(\"Unknown apply setting for param.\");\n        }\n\n        // Apply attribute\n        var dataItem = this;\n        $(target).attr(\n            $(dataItem).attr(\"wfu-attr\"),\n            $(dataItem).attr(\"wfu-attr-val\")\n        );\n\n    });\n\n}\n\n//#endregion\n\n//#region Data Formatting\n\n// MIGRATED to utils.ts\nexport var formatJson = function (data) {\n\n    var json;\n\n    // Convert JSON to string\n    if (typeof data != 'string') {\n        json = JSON.stringify(data, undefined, 2);\n    }\n\n    return json;\n}\n\n// MIGRATED to utils.ts\nexport var formatJsonAsHtml = function (data) {\n\n    // Convert JSON to string\n    var json = formatJson(data);\n\n    json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n\n    // Add JSON styling classes\n    return json.replace(\n        /(\"(\\\\u[a-zA-Z0-9]{4}|\\\\[^u]|[^\\\\\"])*\"(\\s*:)?|\\b(true|false|null)\\b|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)/g,\n        function (match) {\n            var cls = 'wfu-json-number';\n            if (/^\"/.test(match)) {\n                if (/:$/.test(match)) {\n                    cls = 'wfu-json-key';\n                } else {\n                    cls = 'wfu-json-string';\n                }\n            } else if (/true|false/.test(match)) {\n                cls = 'wfu-json-boolean';\n            } else if (/null/.test(match)) {\n                cls = 'wfu-json-null';\n            }\n            return '<span class=\"' + cls + '\">' + match + '</span>';\n        });\n\n}\n\n// MIGRATED to utils.ts \nexport var displayDataAsHtml = function (el, data) {\n\n//    var json = formatJson(data);\n\n    // Create <pre> element\n    $(el).html(\"<pre class='wfu-code'></pre>\");\n\n    // Populate <pre> element with formatted JSON data\n    $(el).children(\"pre\").html(\n        formatJsonAsHtml(data)\n    );\n\n}\n\n//#endregion\n\n//#region Macros\n\n/* expandMacrosInElement\n * Expands {{ var }} constructs in an elements innerHtml\n * using dictionary lookup, and replaces the element content.\n */\n// MIGRATED to utils.ts \nexport var expandMacrosInElement = function (el, dict) {\n\n    var html = $(el).html();\n\n    html = expandMacrosInText(html, dict);\n\n    $(el).html(\n        html\n    );\n\n}\n\n/* expandMacrosInText\n * Expands {{ var }} constructs in text\n */\n// MIGRATED to utils.ts \nexport var expandMacrosInText = function (text, dict) {\n\n    // https://regexr.com/\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n    // Must be positioned before regex replace call\n    var replacer = function (match, p1, p2, p3, offset, string) {\n\n        return dict.get(p2);\n    }\n\n    text = text.replace(\n        /{\\s*(?<cmd>\\w*)\\s*\\{\\s*(?<params>\\w*)\\s*\\}\\s*(?<options>\\w*)\\s*\\}/g,\n        replacer\n    );\n\n    return text;\n}\n\n//#endregion\n\n//#region Nested Lists\n\n/* processList\n * Parses markup in LI's to create nested lists\n * https://codepen.io/memetican/pen/vYjGbrd/8052e3c39d42e8c1e326b2f6ead371c5\n */\n// MIGRATED to webflow-html / nested-list.ts \nexport var processList = function (list) {\n    //        console.log(`LIST -------------------------`);\n\n    var content = $(list).html();\n//    console.log(content);\n\n    var data = $.parseHTML(content);\n    var items = [];\n\n    $.each(data, function (i, el) {\n\n//        console.log(el);\n        \n//        console.log(JSON.stringify(el));\n//        console.log(el.nodeName);\n//        console.log(el.nodeType);\n\n        if (el.nodeName != \"LI\")\n            return; // skip\n\n        var item = {\n            indent: 1,\n            mode: '',\n            text: $(el).html().trim()\n        };\n\n        items.push(item);\n        //        console.log(`${i} ${item.text} ${items.length}`);\n\n        var limit = 10;\n        for (var j = 1; j < limit; j += 1) {\n\n            if (item.text.startsWith(\"&gt;\")) {\n                item.text = item.text.substring(4).trim(); // remove directive \n                item.indent++;\n            } else if (item.text.startsWith(\"+\")) {\n                item.text = item.text.substring(1).trim(); // remove directive \n                item.mode = \"pro\";\n            } else if (item.text.startsWith(\"-\")) {\n                item.text = item.text.substring(1).trim(); // remove directive \n                item.mode = \"con\";\n            } else {\n                break; // done\n            }\n\n        }\n\n    });\n\n    // Render HTML\n    // Creates structured embedded list from the \n    // array data set. \n\n    var outHtml = '';\n    var level = 1;\n    var tag = list.tagName.toLowerCase();\n    var prevLevel = 1;\n\n    $.each(items, function (i, item) {\n\n        // Add optional PRO/CON class \n        var attr = '';\n        if (item.mode == 'pro')\n            attr = \" class='wfu-pro'\";\n        if (item.mode == 'con')\n            attr = \" class='wfu-con'\";\n\n        prevLevel = level;\n\n        if (item.indent > level) {\n\n            for (var l = level + 1; l <= item.indent; l += 1)\n                outHtml += `<${tag} class=\"wfu-list-level-${l}\">`;\n            outHtml += `<li${attr}>${item.text}`;\n\n            level = item.indent;\n\n        } else if (item.indent < level) {\n\n            outHtml += `</li></${tag}>`.repeat(level - item.indent);\n            outHtml += `</li>`;\n            outHtml += `<li${attr}>${item.text}`;\n            level = item.indent;\n\n        } else {\n\n            if (i > 0)\n                outHtml += `</li>`;\n            outHtml += `<li${attr}>${item.text}`;\n\n        }\n\n    });\n\n    if (level > 1)\n        outHtml += `</li></${tag}>`.repeat(level - 1);\n    outHtml += `</li>`;\n    level = 1;\n\n    $(list).html(outHtml);\n\n}\n\n//#endregion\n\n// MIGRATED to utils.ts \nexport var sequence = function (l) {\n\n    const $group = $(l);\n    \n    // Get the group name\n    const groupName = $group.attr(\"wfu-seq-group\");\n\n    // Find matching items \n    var i = 0;\n    $group.find(`[wfu-seq=\"${groupName}\"]`).each(function() {\n        $(this).html(++i);\n    }); \n\n}\n\n//#region Sorting\n\n/* sortCollectionList\n * Sorts a Collection List\n * https://codepen.io/memetican/pen/oNygGLj/259b05cd6be71a16d2f4787e0714278f\n */\n// MIGRATED to utils.ts \nexport var sortCollectionList = function (l) {\n\n    console.group(\"SORT\");\n\n    const $list = $(l);\n    const mode = $list.attr(\"wfu-sort\") || \"default\";\n    const dir = $list.attr(\"wfu-sort-dir\") || \"asc\";\n    const sortType = $list.attr(\"wfu-sort-type\") || \"string\";\n\n    var $items = $list.children();\n\n    console.debug(`WFU sorting ${mode} ${sortType} ${dir} (${$items.length} children)`);\n\n    console.debug({\n        name: \"WFU sorting\", \n        mode: mode, \n        sortType: sortType, \n        dir: dir, \n        children: `${$items.length} children`\n    });\n\n    console.debug('before.');\n\n    console.debug($list.children()); \n\n    // If Random sort, do it now \n    // uses jQuery extension, defined above\n    if(dir == \"random\") {\n\n        // Randomize\n        // updates element order directly, immediately\n        $list.children().shuffle();\n\n    } else {\n\n        $items.sort(function (a, b) {\n\n            const key1 = $(a).find(\"[wfu-sort-key]\").attr(\"wfu-sort-key\");\n            const key2 = $(b).find(\"[wfu-sort-key]\").attr(\"wfu-sort-key\");\n\n            // Determine asc sort result\n            var sortResult = 1;\n            switch (sortType) {\n                case \"date\":\n\n                    sortResult = new Date(key1) < new Date(key2) ? -1 : 1;\n                    console.debug(`comparing dates ${key1} ${key2} = ${sortResult}`);\n\n                    break;\n                case \"number\":\n\n                    sortResult = new Number(key1) < new Number(key2) ? -1 : 1;\n                    console.debug(`comparing numbers ${key1} ${key2} = ${sortResult}`);\n\n                    break;\n                case \"semver\":\n\n                    const semver1 = `${key1}.0.0.0`.split('.');\n                    const semver2 = `${key2}.0.0.0`.split('.');\n\n                    // https://semver.org/#spec-item-11\n\n                    // Precedence is determined by the first difference when comparing each \n                    // of these identifiers from left to right as follows: \n                    // Major, minor, and patch versions are always compared numerically.\n                    for (var p = 0; p < 4; p++) \n                        if (semver1[p] != semver2[p])\n                            break;\n\n                    // Numeric identifiers always have lower precedence than non-numeric identifiers.\n\n                    // Identifiers with letters or hyphens are compared lexically in ASCII sort order.\n\n                        // https://semver.org/#:~:text=Precedence%20for%20two%20pre%2Drelease%20versions%20with%20the%20same%20major%2C%20minor%2C%20and%20patch\n\n    //                console.log(`semver difference at part ${p}`);\n\n                    // Identifiers consisting of only digits are compared numerically.\n\n                    // Compare; if same, doesn't matter\n                    sortResult = new Number(semver1[p]) < new Number(semver2[p]) ? -1 : 1;\n                    console.debug(`comparing semvers ${key1} ${key2} = ${sortResult}`);\n\n                    break;\n                case \"string\":\n                default:\n\n                    sortResult = key1.localeCompare(key2);\n                    console.debug(`comparing strings ${key1} ${key2} = ${sortResult}`);\n\n                    break;\n            }\n\n            // Invert for desc\n            if (dir != \"asc\") {\n                sortResult = sortResult * -1;\n            }\n\n            return sortResult;\n        });\n\n        console.debug('writing.');\n        $list.html($items);\n\n    }\n\n    // Remove attribute to display \n    $list.removeAttr(\"wfu-sort\");\n\n    console.groupEnd();\n\n}\n\n//#endregion\n", "\n/*\n * Sygnal Technology Group\n * http://sygnal.com\n *\n * Data-processing functions.\n */\n\nimport { csvToObjects } from './webflow-data-csv.js';\nimport { prepareCollectionListDataSource } from '../datasources/webflow-collectionlist-data.js';\nimport { loadGoogleSheetFromSpec } from '../datasources/google-sheet-data.js';\nimport { HtmlBuilder } from './webflow-html-builder.js';\n\nexport class Database {\n    data = new Map();\n\n    normalizeKey = function (key) {\n        return key.toLowerCase();\n    }\n\n    // Add specified JSON document under key.\n    add = function (key, json) {\n\n        key = this.normalizeKey(key);\n\n        // Convert string to JSON\n        if (typeof json == 'string') {\n            json = JSON.parse(json);\n        }\n\n        this.data.set(key, json);\n    }\n\n    getData = function (key) {\n\n        key = this.normalizeKey(key);\n\n        return this.data.get(key);\n    }\n    getDataSource = this.getData; // obsolete\n\n    getCountOfRecords = function (dataSourceName) {\n        return this.getDataSource(dataSourceName).length;\n    }\n\n    getDictionary = function (dataSourceName, keyField, valueField) {\n        var dict = new Map();\n\n        var ds = this.getDataSource(dataSourceName);\n\n//        console.log(ds);\n\n        for (var i = 0; i < ds.length; i++)\n        {\n//            console.log(`${0}: ${ds.length} ${ds[i].keyField} / ${ds[i].valueField}`);\n            dict.set(\n                ds[i][keyField],\n                ds[i][valueField]\n            );\n        }\n\n        console.log(dict);\n        return dict;\n    }\n\n    getDictionaryFromRow = function (dataSourceName, row) {\n        var dict = new Map();\n\n        var ds = this.getDataSource(dataSourceName);\n\n        for (const v in ds[row]) {\n            dict.set(\n                v,\n                ds[row][v]\n            );\n        }\n\n        return dict;\n    }\n\n}\n\n/* Loads all data sources\n * tagged with [wfu-data]\n */\nexport var loadAllData = function () {\n\n    // Find all elements which specify a data-source\n    // for data binding\n    var dataSources = $('*[wfu-data]');\n\n    console.log(`sources found = ${dataSources.length}`);\n\n    var db = new Database();\n\n    // Iterate and bind each individually\n    $.each(dataSources, function (i, elem) {\n\n        console.log(`processing source - ${elem.getAttribute(\"wfu-data\")}`);\n\n        var data = loadData(\n            elem.getAttribute(\"wfu-data\")\n        );\n\n        // add to database\n        db.data.set(\n            elem.getAttribute(\"wfu-data\"),\n            data\n        );\n    })\n\n    return db;\n}\n\nexport var loadData = function (name) {\n\n    // Find all elements which identify themselves\n    // as a data-source\n    var dataSource = $(`*[wfu-data='${name}']`);\n    if (!dataSource) {\n        console.warn(`Datasource: '${name}' does not exist`);\n        return;\n    }\n\n    // Get data type\n    var dataSourceType = $(dataSource).attr(\"wfu-data-type\");\n    console.log(`preparing data - ${dataSourceType}`);\n\n    switch (dataSourceType) {\n        case 'collection-list': // Webflow collection list\n            return prepareCollectionListDataSource(dataSource);\n            break;\n        case 'json': // static json chunk\n            break;\n        case 'google-sheet': // Google sheet link\n            return loadGoogleSheetFromSpec(\n                JSON.parse(\n                    $(dataSource).text()\n                )\n            );\n            break;\n        default:\n            console.error(`Data-source type: '${dataSourceType}' unknown`);\n            break;\n    }\n\n}\n\nexport var getCsv = function (url) {\n\n    var csv = null;\n\n    $.ajax({\n        url: url,\n        async: false, // deprecated\n        success: function (csvd) {\n\n            csv = csvd;\n\n        },\n        dataType: \"text\",\n        complete: function () {\n            // call a function on complete\n        }\n    });\n\n    return csv;\n}\n\nexport var csvToData = function (csvd) { \n\n    var items = csvToObjects(csvd);\n\n    //var json = JSON.stringify(\n    //    items,\n    //    null,\n    //    prettyprint ? 2 : 0 // pretty print\n    //);\n\n    return items;\n}\n\n/* Return Csv as JSON objects\n * \n */\nexport var getCsvAsData = function (url) {\n\n    var data = null;\n\n    $.ajax({\n        url: url,\n        async: false, // deprecated\n        success: function (csvd) {\n\n            data = csvToObjects(csvd);\n\n            //json = JSON.stringify(\n            //    items,\n            //    null,\n            //    prettyprint ? 2 : 0 // pretty print\n            //);\n\n        },\n        dataType: \"text\",\n        complete: function () {\n            // call a function on complete\n        }\n    });\n\n    return data;\n}\n\nexport var getDictionaryFromDataRow = function (data, rowIndex) {\n    var dict = new Map();\n\n    for (const v in data[rowIndex]) {\n        dict.set(\n            v,\n            data[rowIndex][v]\n        );\n    }\n\n    return dict;\n}\n\n\n\n", "\n/*\n * google-sheet-data\n *\n * Sygnal Technology Group\n * http://sygnal.com\n *\n * Extracts information from Google Sheets, and returns as JSON\n */\n\n//import { csvToData } from '../modules/webflow-data.js';\n//import { csvToObjects } from '../modules/webflow-data-csv.js';\nimport { getCsvAsData } from '../modules/webflow-data.js';\n\nexport var loadGoogleSheetFromSpec = function (spec) {\n\n    switch (spec.version) {\n        default:\n        case \"1\":\n\n            return getCsvAsData(spec.url);\n//            return getGoogleSheetDataUrl(spec.url);\n\n            break;\n    }\n//    console.log(spec);\n\n    // Validate spec\n    // TODO: cast to options-style object? \n\n//    spec.url\n}\n\n// Returns a Url to retrieve the CSV version of a Google Sheet\n// The sheet must be publicly accessible.\nexport var getGoogleSheetCsvUrl = function (id) {\n\n    return `https://docs.google.com/spreadsheets/d/${id}/export?format=csv`;\n}\n\n// Returns all data as JSON from Sheet1\nexport var getGoogleSheetData = function (id) {\n\n    return new Promise((resolve, reject) => {\n\n        var url = getGoogleSheetCsvUrl(id);\n        console.log(url);\n\n        var json = getCsvAsData(\n            getGoogleSheetCsvUrl(id)\n        );\n\n        resolve(json);\n\n    });\n}\n\n// Returns all data as JSON from Sheet1\nexport var getGoogleSheetDataUrl = function (url) {\n\n    return new Promise((resolve, reject) => {\n\n        console.log(url);\n\n        var json = getCsvAsData(\n            url\n        );\n\n        resolve(json);\n\n    });\n}", "\n\n\n\nexport class Database {\n    data = new Map();\n\n    normalizeKey = function (key) {\n        return key.toLowerCase();\n    }\n\n    // Add specified JSON document under key.\n    add = function (key, json) {\n\n        key = this.normalizeKey(key);\n\n        // Convert string to JSON\n        if (typeof json == 'string') {\n            json = JSON.parse(json);\n        }\n\n        this.data.set(key, json);\n    }\n\n    getData = function (key) {\n\n        key = this.normalizeKey(key);\n\n        return this.data.get(key);\n    }\n    getDataSource = this.getData; // obsolete\n\n    getCountOfRecords = function (dataSourceName) {\n        return this.getDataSource(dataSourceName).length;\n    }\n\n    getDictionary = function (dataSourceName, keyField, valueField) {\n        var dict = new Map();\n\n        var ds = this.getDataSource(dataSourceName);\n\n//        console.log(ds);\n\n        for (var i = 0; i < ds.length; i++)\n        {\n//            console.log(`${0}: ${ds.length} ${ds[i].keyField} / ${ds[i].valueField}`);\n            dict.set(\n                ds[i][keyField],\n                ds[i][valueField]\n            );\n        }\n\n        console.log(dict);\n        return dict;\n    }\n\n    getDictionaryFromRow = function (dataSourceName, row) {\n        var dict = new Map();\n\n        var ds = this.getDataSource(dataSourceName);\n\n        for (const v in ds[row]) {\n            dict.set(\n                v,\n                ds[row][v]\n            );\n        }\n\n        return dict;\n    }\n\n} \n\n", "\n/*\n * SA5\n * Sygnal Technology Group\n * sa5-data\n * \n * Creates a data source from SA5 data.\n */\n\n// import { Database } from '../modules/webflow-data.js';\n\nimport { Sa5ScriptType } from '../globals'\n\ntype SA5Object = { [key: string]: any };\n\nexport class Sa5Data {\n\n    elem: HTMLElement;\n    type: string;\n    value: SA5Object;\n\n    constructor(elem: HTMLElement) {\n\n        this.elem = elem; \n        this.init();\n\n    }\n\n    init() {\n\n        // Verify node type\n        if (this.elem.nodeName != \"SCRIPT\") {\n            console.error(\"Invalid element for Sa5Data. Must be a SCRIPT element.\", this.elem);\n            return;\n        }\n        \n        // Verify type\n        this.type = this.elem.getAttribute(\"type\");\n        if (this.type != Sa5ScriptType.SCRIPT_TYPE_SA5_DATA_ITEM) {\n            console.error(\"Invalid element type for Sa5Data.\", this.elem);\n            return; \n        }\n\n        let data = this.elem.innerText;\n\n        this.value = this.parse(data); \n\n    }\n\n    parse(content: string): SA5Object | null {\n        const obj: SA5Object = {};\n        const lines = content.split('\\n');\n        let currentKey: string | null = null;\n        let currentValue: string | null = null;\n        let currentType: 'string' | 'number' | 'boolean' = 'string';\n        let isMultiLineValue = false;\n    \n        for (let line of lines) {\n            line = line.trim();\n            \n            // Skip empty lines\n            if (!line) continue;\n    \n            // Handle multi-line values\n            if (isMultiLineValue) {\n                if (line.endsWith('>')) {\n                    currentValue += '\\n' + line.slice(0, -1); // Exclude the closing '>'\n                    if (currentKey !== null && currentValue !== null) {\n                        switch (currentType) {\n                            case 'number':\n                                obj[currentKey] = parseFloat(currentValue);\n                                break;\n                            case 'boolean':\n                                obj[currentKey] = currentValue.toLowerCase() === 'true';\n                                break;\n                            default:\n                                obj[currentKey] = currentValue;\n                                break;\n                        }\n                    }\n                    isMultiLineValue = false;\n                    currentValue = null;\n                    currentKey = null;\n                    currentType = 'string';\n                } else {\n                    currentValue += '\\n' + line;\n                }\n                continue;\n            }\n    \n            const delimiterMatch = line.match(/:(\\$|#|\\?|)/);\n            if (!delimiterMatch) continue;\n    \n            const delimiter = delimiterMatch[1];\n            const parts = line.split(delimiterMatch[0]);\n            const key = parts[0].trim();\n            let value = parts.slice(1).join(':').trim();\n    \n            // Determine the type based on the delimiter\n            switch (delimiter) {\n                case '':\n                case '$':\n                    currentType = 'string';\n                    break;\n                case '#':\n                    currentType = 'number';\n                    break;\n                case '?':\n                    currentType = 'boolean';\n                    break;\n            }\n    \n            // Handle starting of multi-line value\n            if (value.startsWith('<')) {\n                if (value.endsWith('>')) {\n                    value = value.slice(1, -1); // Exclude both the starting '<' and closing '>'\n                    switch (currentType) {\n                        case 'number':\n                            obj[key] = parseFloat(value);\n                            break;\n                        case 'boolean':\n                            obj[key] = value.toLowerCase() === 'true';\n                            break;\n                        default:\n                            obj[key] = value;\n                            break;\n                    }\n                } else {\n                    isMultiLineValue = true;\n                    currentKey = key;\n                    currentValue = value.slice(1); // Exclude the starting '<'\n                }\n            } else {\n                switch (currentType) {\n                    case 'number':\n                        obj[key] = parseFloat(value);\n                        break;\n                    case 'boolean':\n                        obj[key] = value.toLowerCase() === 'true';\n                        break;\n                    default:\n                        obj[key] = value;\n                        break;\n                }\n            }\n        }\n    \n        return obj;\n    }\n\n    parse2(content: string): SA5Object | null {\n        const obj: SA5Object = {};\n        const lines = content.split('\\n');\n        let currentKey: string | null = null;\n        let currentValue: string | null = null;\n        let isMultiLineValue = false;\n\n        for (let line of lines) {\n            line = line.trim();\n            \n            // Skip empty lines\n            if (!line) continue;\n\n            // Handle multi-line values\n            if (isMultiLineValue) {\n                if (line.endsWith('>')) {\n                    currentValue += '\\n' + line.slice(0, -1); // Exclude the closing '>'\n                    if (currentKey !== null && currentValue !== null) {\n                        obj[currentKey] = currentValue;\n                    }\n                    isMultiLineValue = false;\n                    currentValue = null;\n                    currentKey = null;\n                } else {\n                    currentValue += '\\n' + line;\n                }\n                continue;\n            }\n\n            const parts = line.split(':');\n            const key = parts.shift()?.trim() || \"\";\n            const value = parts.join(':').trim();\n\n            // Handle starting of multi-line value\n            if (value.startsWith('<')) {\n                if (value.endsWith('>')) {\n                    obj[key] = value.slice(1, -1); // Exclude both the starting '<' and closing '>'\n                } else {\n                    isMultiLineValue = true;\n                    currentKey = key;\n                    currentValue = value.slice(1); // Exclude the starting '<'\n                }\n            } else {\n                obj[key] = value;\n            }\n        }\n\n        return obj;\n    }\n\n}\n\n\n\n", "\n/*\n * Sygnal Technology Group\n * http://sygnal.com\n *\n * Data-processing functions.\n */ \n\nimport { Sa5Core } from './webflow-core';\nimport { Sa5Debug } from './webflow-core/debug';\n\n//import { csvToObjects } from './webflow-data/webflow-data-csv';\nimport { prepareCollectionListDataSource } from './webflow-data/webflow-collectionlist-data';\nimport { loadGoogleSheetFromSpec } from './webflow-data/google-sheet-data';\n//import { HtmlBuilder } from './webflow-html-builder.js';\nimport { Database } from './webflow-data/database';\nimport { Sa5Attribute, Sa5GlobalEvent, Sa5ScriptType } from './globals';\n\nimport { Sa5Data } from './webflow-data/sa5-data';\n\n\ntype DatabaseStore = {\n    [key: string]: Database;\n};\n\ntype DataItem = {\n    dsn: string, \n    version: string,\n    id: string,\n    item: any,\n}\n\n\ntype DatastoreLoadedCallback = (dataStore: Sa5Datastore) => void;\n\n\n\n\ninterface Sa5DatastoreConfig {\n//    loadUserInfoCallback?: ((user: Sa5User) => void) | undefined; // Function callback \n    datastoreLoadedCallback?: DatastoreLoadedCallback; \n//    userLogoutPurge?: ((user: Sa5User) => void) | undefined;\n\n    debug?: boolean;\n\n//    dataBind?: boolean; // Databind after user object load \n\n    // Advanced settings\n    // advanced: {\n\n    //     accountInfoLoadDelay: number; // ms \n    //     accountInfoSaveDelay: number; // ms \n\n    // }\n}\n\n\n\n\nexport class Sa5Datastore {\n\n    store: DatabaseStore = {};\n\n    config: Sa5DatastoreConfig; // Optional config\n\n    // Type guard to check if a function is a UserInfoChangedCallback\n    private isDatastoreLoadedCallback(func: Function): func is DatastoreLoadedCallback {\n\n        if(!func) return false;\n\n        // Adjust this check as needed\n        return func.length === 1;\n    }\n\n    constructor(config: Partial<Sa5DatastoreConfig> = {}) {\n\n        // Merge configs, with defaults\n        this.config = {\n            datastoreLoadedCallback: config.datastoreLoadedCallback,\n            debug: config.debug ?? false,\n        }\n\n    }\n\n    init() {\n\n        // Load internal dbs\n        this.init_dbs(); \n\n        // Callback for other registered data sources \n        // Spreadsheet csv's \n        // etc. \n\n        let core: Sa5Core = Sa5Core.startup();\n\n        // Get any global handler\n        const datastoreLoaded = core.getHandler(Sa5GlobalEvent.EVENT_DATASTORE_LOADED); \n        if (this.isDatastoreLoadedCallback(datastoreLoaded)) {\n\n            this.config.datastoreLoadedCallback = datastoreLoaded;\n\n        }\n\n        // User Callback \n        if (this.config.datastoreLoadedCallback) {\n//            this.debug.debug(\"userCallback\", user);\n            this.config.datastoreLoadedCallback(this); // async\n        }\n\n    }\n\n    loadDataItem(elem: HTMLElement) {\n       \n        let data = this.loadDataItem_v2(\n            elem\n//            elem.getAttribute(\"wfu-data\"),\n//            dataObject\n        );\n\n    }\n\n    // loadDataItem_v1(dbName: string, value: object): void {\n\n    //     if (!this.store[dbName])\n    //         this.store[dbName] = new Database();\n\n    //     this.store[dbName].add(value.slug, value)\n\n    // }\n\n    loadDataItem_v2(elem: HTMLElement): void {\n\n        const dsn = elem.getAttribute(Sa5Attribute.ATTR_DATA_DSN); //  \"wfu-data-dsn\");\n        const id = elem.getAttribute(Sa5Attribute.ATTR_DATA_ITEM_ID); // \"wfu-data-item-id\"); \n\n// console.log(\"load data v2\", dsn, id); \n\n // console.log(elem.innerText); \n\n        let dataObject = JSON.parse(elem.innerText); \n\n\n// console.log(dataObject);  \n\n        // Ensure db is created\n        if (!this.store[dsn])\n            this.store[dsn] = new Database();\n\n        // Add item\n        this.store[dsn].add(id, dataObject);\n\n    }\n\n    loadDataItem_sa5Data(elem: HTMLElement): void {\n\n        const dsn = elem.getAttribute(Sa5Attribute.ATTR_DATA_DSN); //  \"wfu-data-dsn\");\n        const id = elem.getAttribute(Sa5Attribute.ATTR_DATA_ITEM_ID); // \"wfu-data-item-id\"); \n\n        let i = new Sa5Data(elem)\n        let dataObject = i.value; \n\n        console.log(\"dataObject\", dataObject);\n\n        // Ensure db is created\n        if (!this.store[dsn])\n            this.store[dsn] = new Database();\n\n        // Add item\n        this.store[dsn].add(id, dataObject);\n\n    }\n\n    init_dbs() { \n\n        // Init databases \n\n        // Find all elements which specify a data-source for data binding\n        let sa5DataSources = document.querySelectorAll(\n            `script[type='${Sa5ScriptType.SCRIPT_TYPE_SA5_DATA_ITEM}']`\n        ); // wfu-data-item\n\n        // Iterate and bind each individually\n        sa5DataSources.forEach((elem: HTMLElement) => {\n\n            this.loadDataItem_sa5Data(elem);\n\n        });\n\n        // Find all elements which specify a data-source for data binding\n        let dataSources = document.querySelectorAll(\n            `script[type='${Sa5ScriptType.SCRIPT_TYPE_DATA_ITEM}']`\n        ); // wfu-data-item\n//        console.log(`data-items found = ${dataSources.length}`);\n\n        // Iterate and bind each individually\n        dataSources.forEach((elem: HTMLElement) => {\n//             console.log(`processing source - ${elem.getAttribute(\"wfu-data\")}`);\n\n            this.loadDataItem(elem);\n\n//             let dataObject = JSON.parse(elem.innerText); \n//             console.log(dataObject);  \n\n// // dataObject\n\n\n//             let data = this.loadDataItem(\n//                 elem.getAttribute(\"wfu-data\"),\n//                 dataObject\n//             );\n\n            // add to database\n            // db.data.set(\n            //     elem.getAttribute(\"wfu-data\")!,\n            //     data\n            // );\n        });\n\n //        return db;\n    }\n\n    loadData(name: string) {\n        // Find all elements which identify themselves as a data-source\n        let dataSource = document.querySelector(\n            `[${Sa5Attribute.ATTR_DATA}='${name}']`\n            );\n        if (!dataSource) {\n            console.warn(`Datasource: '${name}' does not exist`);\n            return;\n        }\n\n        // Get data type\n        let dataSourceType = dataSource.getAttribute(Sa5Attribute.ATTR_DATA_TYPE); // \"wfu-data-type\");\n        console.log(`preparing data - ${dataSourceType}`);\n\n        switch (dataSourceType) {\n            case 'collection-list': // Webflow collection list\n                return prepareCollectionListDataSource(dataSource as HTMLElement);\n            case 'json': // static json chunk\n                break;\n            case 'google-sheet': // Google sheet link\n                return loadGoogleSheetFromSpec(\n                    JSON.parse(\n                        dataSource.textContent || \"\"\n                    )\n                );\n            default:\n                console.error(`Data-source type: '${dataSourceType}' unknown`);\n                break;\n        }\n    }\n\n    async getCsv(url: string): Promise<string | null> {\n        let csv: string | null = null;\n\n        try {\n            const response = await fetch(url);\n            if (response.ok) {\n                csv = await response.text();\n            } else {\n                console.error(`Error fetching CSV: ${response.status}`);\n            }\n        } catch (error) {\n            console.error(`Error fetching CSV: ${error}`);\n        }\n\n        return csv;\n    }\n\n    csvToData(csvd: string): any[] { \n        let items = null; // BUG: csvToObjects(csvd);\n\n        //let json = JSON.stringify(\n        //    items,\n        //    null,\n        //    prettyprint ? 2 : 0 // pretty print\n        //);\n\n        return items;\n    }\n\n    /* Return Csv as JSON objects\n    * \n    */\n    async getCsvAsData(url: string): Promise<any[] | null> {\n        let data: any[] | null = null;\n\n        try {\n            const response = await fetch(url);\n            if (response.ok) {\n                const csvd = await response.text();\n    // BUG:            data = csvToObjects(csvd);\n            } else {\n                console.error(`Error fetching CSV: ${response.status}`);\n            }\n        } catch (error) {\n            console.error(`Error fetching CSV: ${error}`);\n        }\n\n        return data;\n    }\n\n    getDictionaryFromDataRow(data, rowIndex) {\n        var dict = new Map();\n\n        for (const v in data[rowIndex]) {\n            dict.set(\n                v,\n                data[rowIndex][v]\n            );\n        }\n\n        return dict;\n    }\n\n}\n"],
  "mappings": ";;AAYO,MAAM,WAAN,MAAe;AAAA,IAyClB,YAAY,OAAe;AAvC3B,WAAQ,wBAAgC;AAExC,WAAQ,WAAoB;AAwCxB,WAAK,SAAS;AAAA,IAElB;AAAA,IArCA,IAAI,kBAA2B;AAC3B,aAAO,QAAQ,aAAa,QAAQ,KAAK,qBAAqB,CAAC;AAAA,IACnE;AAAA,IACA,IAAI,gBAAgB,QAAiB;AACjC,UAAI,QAAQ;AACR,qBAAa,QAAQ,KAAK,uBAAuB,MAAM;AACvD,gBAAQ,MAAO,sCAAsC;AAAA,MACzD,OAAO;AACH,qBAAa,WAAW,KAAK,qBAAqB;AAClD,gBAAQ,MAAO,uCAAuC;AAAA,MAC1D;AAAA,IACJ;AAAA,IAGA,IAAI,UAAmB;AAInB,UAAI,gBAAgB,QAAQ,aAAa,QAAQ,KAAK,qBAAqB,CAAC;AAI5E,sBAAgB,iBAAiB,KAAK;AAEtC,aAAO;AAAA,IACX;AAAA,IACA,IAAI,QAAQ,QAAiB;AACzB,WAAK,WAAW;AAAA,IACpB;AAAA,IAaA,MAAM,MAAM;AACR,UAAI,KAAK;AACL,gBAAQ,MAAM,IAAI;AAAA,IAC1B;AAAA,IAGA,WAAW;AACP,UAAI,KAAK;AACL,gBAAQ,SAAS;AAAA,IACzB;AAAA,IAGA,SAAS,MAAmB;AAExB,UAAI,KAAK;AAGL,gBAAQ,MAAM,KAAK,QAAQ,GAAG,IAAI;AAAA,IAE1C;AAAA,EAEJ;;;AC1DO,MAAM,UAAN,MAAc;AAAA,IA0BjB,cAAc;AAvBd,WAAO,WAAW,CAAC;AAAA,IAyBnB;AAAA,IAvBA,YAAY,MAA0B;AAElC,aAAO,KAAK,SAAS,OAAO,UAAQ,KAAK,OAAO,IAAI,EAC/C,IAAI,UAAQ,KAAK,EAAE;AAAA,IAG5B;AAAA,IAEA,WAAW,MAAoC;AAC3C,YAAM,OAAO,KAAK,SACb,KAAK,CAAAA,UAAQA,MAAK,OAAO,IAAI;AAClC,aAAO,OAAO,KAAK,KAAK;AAAA,IAC5B;AAAA,IAaA,OAAO;AAEH,WAAK,cAAc;AAAA,IAEvB;AAAA,IAIA,gBAAgB;AAEZ,YAAM,gBAAgB;AAItB,UAAI,SAAS,IAAI,gBAAgB,OAAO,SAAS,MAAM;AACvD,UAAI,WAAW,OAAO,IAAI,aAAa;AAEvC,UAAI,UAAU;AACV,YAAI,WAAW,IAAI,SAAS,UAAU;AACtC,iBAAS,kBAAkB,KAAK,gBAAgB,OAAO,IAAI,aAAa,CAAC;AAAA,MAC7E;AAAA,IAEJ;AAAA,IAEA,gBAAgB,KAAsB;AAClC,YAAM,eAAyB,CAAC,KAAK,QAAQ,KAAK;AAClD,YAAM,cAAwB,CAAC,KAAK,SAAS,IAAI;AAEjD,UAAI,aAAa,QAAQ,IAAI,YAAY,CAAC,MAAM,IAAI;AAChD,eAAO;AAAA,MAGX,OAAO;AACH,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,IAIA,OAAO,QAAQ,SAAqB,MAAe;AAO/C,UAAI,cAAc,OAAO;AAEzB,UAAI;AAIJ,UAAG,aAAa,aAAa,QAAQ,WAAW;AAE5C,eAAO;AAAA,MAEX,OAAO;AAKH,eAAO,IAAI,QAAQ;AAGnB,YAAG,MAAM,QAAQ,WAAW;AACxB,eAAK,WAAW;AAEpB,eAAO,SAAS;AAChB,eAAO,SAAS,OAAO;AAAA,MAG3B;AAIA,UAAI,QAAQ;AAIR,eAAO,OAAO,OAAO,QAAQ;AAAA,MAEjC;AAIA,aAAO;AAAA,IACX;AAAA,IAGA,KAAK,GAAG;AACJ,WAAK,SAAS,KAAK,CAAC;AAAA,IACxB;AAAA,EAEJ;AAKA,UAAQ,QAAQ;;;AC9IT,MAAM,kCAAkC,CAAC,eAAwB;AAEpE,QAAI,OAAO,WAAW,iBAAiB,QAAQ;AAC/C,YAAQ,IAAI,WAAW,KAAK,QAAQ;AAEpC,QAAI,QAAkB,CAAC;AACvB,SAAK,QAAQ,CAAC,SAAS;AACnB,YAAM,KAAK,KAAK,eAAe,EAAE;AAAA,IACrC,CAAC;AAED,QAAI,OAAO,MAAM,MAAM,KAAK,IAAI;AAEhC,WAAO,KAAK,MAAM,IAAI;AAAA,EAC1B;;;ACUA,SAAO,SAAS,SAAU,GAAG;AACzB,WAAO,EAAE,QAAQ,yBAAyB,MAAM;AAAA,EACpD;AAEA,MAAI,WAAW;AAAA,IACX,WAAW;AAAA,IACX,WAAW;AAAA,IACX,SAAS;AAAA,EACb;AAsNA,MAAI,aAAa,SAAU,KAAK,SAAS;AACrC,QAAI,CAAC,KAAK;AACN,aAAO;AAAA,IACX;AAEA,cAAU,WAAW,CAAC;AAGtB,UAAM,YAAY,QAAQ,aAAa,EAAE,IAAI,SAAS;AACtD,UAAM,YAAY,QAAQ,aAAa,EAAE,IAAI,SAAS;AAGtD,YAAQ,QAAQ,QAAQ,SAAS,CAAC;AAClC,QAAI,CAAC,QAAQ,MAAM,QAAQ;AACvB,cAAQ,MAAM,SAAS;AAAA,IAC3B;AAGA,UAAM,UAAU,CAAC;AACjB,QAAI,QAAQ;AACZ,QAAI,QAAQ;AACZ,QAAI,OAAO;AAEX,aAAS,YAAY;AAEjB,cAAQ;AAGR,UAAI,QAAQ,SAAS,QAAQ,MAAM,SAAS,QAAQ,OAAO;AAEvD,gBAAQ;AACR,gBAAQ,MAAM;AACd;AAAA,MACJ;AAEA,UAAI,QAAQ,iBAAiB,QAAW;AAEpC,gBAAQ,KAAK,KAAK;AAAA,MACtB,OAAO;AACH,cAAM,UAAU,QAAQ,aAAa,OAAO,QAAQ,KAAK;AAEzD,YAAI,YAAY,OAAO;AACnB,kBAAQ,KAAK,OAAO;AAAA,QACxB;AAAA,MACJ;AAGA,cAAQ;AAGR,UAAI,QAAQ,OAAO,QAAQ,MAAM,UAAU,QAAQ,KAAK;AACpD,eAAO;AAAA,MACX;AAGA,cAAQ,MAAM;AAAA,IAClB;AAGA,UAAM,eAAe,OAAO,OAAO,SAAS;AAC5C,UAAM,eAAe,OAAO,OAAO,SAAS;AAG5C,QAAI,QAAQ;AACZ,QAAI,WAAW,MAAM;AACrB,eAAW,SAAS,QAAQ,MAAM,YAAY;AAC9C,eAAW,SAAS,QAAQ,MAAM,YAAY;AAC9C,YAAQ,IAAI,OAAO,UAAU,IAAI;AAIjC,QAAI,QAAQ,OAAO,SAAU,IAAI;AAC7B,UAAI,MAAM;AACN;AAAA,MACJ;AACA,cAAQ,OAAO;AAAA,QAEX,KAAK;AAED,cAAI,OAAO,WAAW;AAClB,qBAAS;AACT,oBAAQ;AACR;AAAA,UACJ;AAEA,cAAI,OAAO,WAAW;AAClB,qBAAS;AACT,oBAAQ;AACR;AAAA,UACJ;AAEA,cAAI,OAAO,MAAM;AACb,sBAAU;AACV;AAAA,UACJ;AAEA,cAAI,OAAO,KAAK,EAAE,GAAG;AACjB;AAAA,UACJ;AAEA,mBAAS;AACT,kBAAQ;AACR;AAAA,QAGJ,KAAK;AAED,cAAI,OAAO,WAAW;AAClB,qBAAS;AACT,oBAAQ;AACR;AAAA,UACJ;AAEA,mBAAS;AACT,kBAAQ;AACR;AAAA,QAGJ,KAAK,GAAG;AAEJ,gBAAM,WAAW,MAAM,OAAO,MAAM,SAAS,CAAC;AAC9C,cAAI,OAAO,aAAa,aAAa,WAAW;AAC5C,qBAAS;AACT,oBAAQ;AACR;AAAA,UACJ;AAEA,cAAI,OAAO,WAAW;AAClB,qBAAS;AACT,oBAAQ;AACR;AAAA,UACJ;AAEA,cAAI,OAAO,MAAM;AACb,sBAAU;AACV;AAAA,UACJ;AAEA,cAAI,OAAO,MAAM;AACb;AAAA,UACJ;AAEA,gBAAM,MAAM,sCAAsC,QAAQ,MAAM,SAAS,GAAG;AAAA,QAChF;AAAA,QAEA,KAAK;AAED,cAAI,OAAO,WAAW;AAClB,qBAAS;AACT,oBAAQ;AACR;AAAA,UACJ;AAEA,cAAI,OAAO,MAAM;AACb,sBAAU;AACV;AAAA,UACJ;AAEA,cAAI,OAAO,MAAM;AACb;AAAA,UACJ;AAEA,cAAI,OAAO,WAAW;AAClB,kBAAM,MAAM,sCAAsC,QAAQ,MAAM,SAAS,GAAG;AAAA,UAChF;AAEA,gBAAM,MAAM,sCAAsC,QAAQ,MAAM,SAAS,GAAG;AAAA,QAChF;AAEI,gBAAM,MAAM,sCAAsC,QAAQ,MAAM,SAAS,GAAG;AAAA,MACpF;AAAA,IAEJ,CAAC;AAID,QAAI,UAAU,IAAI;AACd,gBAAU;AAAA,IACd;AAEA,WAAO;AAAA,EACX;AAGA,MAAI,aAAa,SAAU,KAAK,SAAS;AAErC,UAAM,YAAY,QAAQ;AAC1B,UAAM,YAAY,QAAQ;AAG1B,QAAI,CAAC,QAAQ,MAAM,QAAQ;AACvB,cAAQ,MAAM,SAAS;AAAA,IAC3B;AACA,QAAI,CAAC,QAAQ,MAAM,QAAQ;AACvB,cAAQ,MAAM,SAAS;AAAA,IAC3B;AAGA,UAAM,QAAQ,CAAC;AACf,QAAI,QAAQ;AACZ,QAAI,QAAQ;AAEZ,aAAS,aAAa;AAClB,UAAI,QAAQ,iBAAiB,QAAW;AAEpC,cAAM,KAAK,KAAK;AAAA,MACpB,OAAO;AACH,cAAM,OAAO,QAAQ,aAAa,OAAO,QAAQ,KAAK;AAEtD,YAAI,SAAS,OAAO;AAChB,gBAAM,KAAK,IAAI;AAAA,QACnB;AAAA,MACJ;AAEA,cAAQ;AACR,cAAQ;AAER,cAAQ,MAAM;AAAA,IAClB;AAGA,QAAI,CAAC,QAAQ,OAAO;AAEhB,YAAM,eAAe,OAAO,OAAO,SAAS;AAC5C,YAAM,eAAe,OAAO,OAAO,SAAS;AAG5C,YAAM,QAAQ;AACd,UAAI,WAAW,MAAM;AACrB,iBAAW,SAAS,QAAQ,MAAM,YAAY;AAC9C,iBAAW,SAAS,QAAQ,MAAM,YAAY;AAC9C,cAAQ,QAAQ,IAAI,OAAO,UAAU,IAAI;AAAA,IAC7C;AAIA,QAAI,QAAQ,QAAQ,OAAO,SAAU,IAAI;AACrC,cAAQ,OAAO;AAAA,QAEX,KAAK;AAED,cAAI,OAAO,WAAW;AAClB,qBAAS;AACT,uBAAW;AACX;AAAA,UACJ;AAEA,cAAI,OAAO,WAAW;AAClB,oBAAQ;AACR;AAAA,UACJ;AAEA,cAAI,OAAO,QAAQ,OAAO,MAAM;AAC5B;AAAA,UACJ;AAEA,mBAAS;AACT,kBAAQ;AACR;AAAA,QAGJ,KAAK;AAED,cAAI,OAAO,WAAW;AAClB,oBAAQ;AACR;AAAA,UACJ;AAEA,mBAAS;AACT,kBAAQ;AACR;AAAA,QAGJ,KAAK;AAED,cAAI,OAAO,WAAW;AAClB,qBAAS;AACT,oBAAQ;AACR;AAAA,UACJ;AAEA,cAAI,OAAO,WAAW;AAClB,uBAAW;AACX;AAAA,UACJ;AAEA,cAAI,OAAO,QAAQ,OAAO,MAAM;AAC5B;AAAA,UACJ;AAEA,gBAAM,MAAM,sCAAsC,QAAQ,MAAM,SAAS,WAAW,QAAQ,MAAM,SAAS,GAAG;AAAA,QAGlH,KAAK;AAED,cAAI,OAAO,WAAW;AAClB,uBAAW;AACX;AAAA,UACJ;AAEA,cAAI,OAAO,QAAQ,OAAO,MAAM;AAC5B;AAAA,UACJ;AAEA,cAAI,OAAO,WAAW;AAClB,kBAAM,MAAM,sCAAsC,QAAQ,MAAM,SAAS,WAAW,QAAQ,MAAM,SAAS,GAAG;AAAA,UAClH;AAEA,gBAAM,MAAM,qCAAqC,QAAQ,MAAM,SAAS,WAAW,QAAQ,MAAM,SAAS,GAAG;AAAA,QACjH;AAEI,gBAAM,MAAM,sCAAsC,QAAQ,MAAM,SAAS,WAAW,QAAQ,MAAM,SAAS,GAAG;AAAA,MACtH;AAAA,IAEJ,CAAC;AAGD,eAAW;AAEX,WAAO;AAAA,EACX;AAwCA,MAAI,UAAU,SAAU,KAAK,SAAS,UAAU;AAE5C,QAAI,YAAY,UAAa,OAAQ,YAAa,YAAY;AAC1D,UAAI,aAAa,QAAW;AACxB,eAAO,QAAQ,MAAM,+DAA+D;AAAA,MACxF;AACA,iBAAW;AACX,gBAAU,CAAC;AAAA,IACf;AAEA,cAAW,YAAY,SAAY,UAAU,CAAC;AAC9C,UAAM,SAAS,CAAC;AAChB,WAAO,WAAa,aAAa,UAAa,OAAQ,aAAc,aAAc,WAAW;AAC7F,WAAO,YAAY,eAAe,UAAU,QAAQ,YAAY,SAAS;AACzE,WAAO,YAAY,eAAe,UAAU,QAAQ,YAAY,SAAS;AACzE,UAAM,QAAS,QAAQ,UAAU,SAAY,QAAQ,QAAQ,CAAC;AAG9D,cAAU;AAAA,MACN,WAAW,OAAO;AAAA,MAClB,WAAW,OAAO;AAAA,MAClB,cAAc,QAAQ;AAAA,MACtB,cAAc,QAAQ;AAAA,MACtB;AAAA,IACJ;AAEA,UAAM,QAAQ,WAAW,KAAK,OAAO;AAGrC,QAAI,CAAC,OAAO,UAAU;AAClB,aAAO;AAAA,IACX,OAAO;AACH,aAAO,SAAS,IAAI,KAAK;AAAA,IAC7B;AAAA,EACJ;AAiFO,MAAI,eAAe,SAAU,KAAK,SAAS,UAAU;AAExD,QAAI,YAAY,UAAa,OAAQ,YAAa,YAAY;AAC1D,UAAI,aAAa,QAAW;AACxB,eAAO,QAAQ,MAAM,+DAA+D;AAAA,MACxF;AACA,iBAAW;AACX,gBAAU,CAAC;AAAA,IACf;AAEA,cAAW,YAAY,SAAY,UAAU,CAAC;AAC9C,UAAM,SAAS,CAAC;AAChB,WAAO,WAAa,aAAa,UAAa,OAAQ,aAAc,aAAc,WAAW;AAC7F,WAAO,YAAY,eAAe,UAAU,QAAQ,YAAY,SAAS;AACzE,WAAO,YAAY,eAAe,UAAU,QAAQ,YAAY,SAAS;AACzE,WAAO,UAAU,aAAa,UAAU,QAAQ,UAAU,SAAS;AACnE,YAAQ,QAAQ,WAAW,UAAU,QAAQ,QAAQ;AAGrD,QAAI,OAAO,SAAS;AAChB,cAAQ;AAAA,IACZ;AACA,QAAI,QAAQ,OAAO,OAAO,SAAS;AAC/B,cAAQ;AAAA,IACZ;AAGA,QAAI,QAAQ,CAAC;AACb,QAAI,OAAO,CAAC;AAEZ,cAAU;AAAA,MACN,WAAW,OAAO;AAAA,MAClB,WAAW,OAAO;AAAA,MAClB,YAAY,QAAQ;AAAA,MACpB,cAAc,QAAQ;AAAA,MACtB,cAAc,QAAQ;AAAA,MACtB,aAAa,QAAQ;AAAA,MACrB,OAAO,QAAQ;AAAA,MACf,KAAK,QAAQ;AAAA,MACb,OAAO;AAAA,QACH,QAAQ;AAAA,QACR,QAAQ;AAAA,MACZ;AAAA,MACA,OAAO;AAAA,MACP,WAAW,QAAQ;AAAA,IACvB;AAGA,UAAM,gBAAgB;AAAA,MAClB,WAAW,OAAO;AAAA,MAClB,WAAW,OAAO;AAAA,MAClB,OAAO;AAAA,MACP,KAAK;AAAA,MACL,OAAO;AAAA,QACH,QAAQ;AAAA,QACR,QAAQ;AAAA,MACZ;AAAA,MACA,SAAS;AAAA,IACb;AAGA,QAAI,QAAQ,eAAe,QAAW;AAClC,YAAM,QAAQ,WAAW,KAAK,QAAQ,KAAK;AAAA,IAC/C;AAGA,UAAM,aAAa,WAAW,KAAK,aAAa;AAChD,UAAM,UAAU,QAAQ,WAAW,IAAI,aAAa;AAGpD,YAAQ,WAAW,KAAK,OAAO;AAG/B,YAAQ,MAAM,SAAS;AACvB,QAAI,SAAS;AACT,cAAQ,MAAM,SAAS;AAAA,IAC3B,OAAO;AACH,cAAQ,MAAM,SAAS;AAAA,IAC3B;AAGA,aAAS,IAAI,GAAG,MAAM,MAAM,QAAQ,IAAI,KAAK,KAAK;AAC9C,YAAM,QAAQ,QAAQ,MAAM,IAAI,OAAO;AACvC,YAAM,SAAS,CAAC;AAChB,eAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACrC,eAAO,QAAQ,MAAM,MAAM;AAAA,MAC/B;AACA,UAAI,QAAQ,cAAc,QAAW;AACjC,aAAK,KAAK,QAAQ,UAAU,KAAK,QAAW,MAAM,CAAC;AAAA,MACvD,OAAO;AACH,aAAK,KAAK,MAAM;AAAA,MACpB;AAGA,cAAQ,MAAM;AAAA,IAClB;AAGA,QAAI,QAAQ,gBAAgB,QAAW;AACnC,aAAO,QAAQ,YAAY,MAAM,QAAQ,KAAK;AAAA,IAClD;AAGA,QAAI,CAAC,OAAO,UAAU;AAClB,aAAO;AAAA,IACX,OAAO;AACH,aAAO,SAAS,IAAI,IAAI;AAAA,IAC5B;AAAA,EACJ;;;ACxzBA,GAAC,SAASC,IAAE;AAER,IAAAA,GAAE,GAAG,UAAU,WAAW;AAEtB,UAAI,WAAW,KAAK,IAAI,GACpB,YAAY,SAAS,KAAK;AACtB,eAAO,KAAK,MAAM,KAAK,OAAO,IAAI,GAAG;AAAA,MACzC,GACA,WAAWA,GAAE,IAAI,UAAU,WAAU;AACjC,YAAI,SAAS,UAAU,SAAS,MAAM,GAClC,SAASA,GAAE,SAAS,OAAO,EAAE,MAAM,IAAI,EAAE;AAC7C,iBAAS,OAAO,QAAQ,CAAC;AACzB,eAAO;AAAA,MACZ,CAAC;AAEJ,WAAK,KAAK,SAAS,GAAE;AACjB,QAAAA,GAAE,IAAI,EAAE,YAAYA,GAAE,SAAS,EAAE,CAAC;AAAA,MACtC,CAAC;AAED,aAAOA,GAAE,QAAQ;AAAA,IAErB;AAAA,EAEJ,GAAG,MAAM;;;ACmJF,MAAI,eAAe,SAAU,KAAK;AAErC,QAAI,OAAO;AAEX,MAAE,KAAK;AAAA,MACH;AAAA,MACA,OAAO;AAAA,MACP,SAAS,SAAU,MAAM;AAErB,eAAO,aAAa,IAAI;AAAA,MAQ5B;AAAA,MACA,UAAU;AAAA,MACV,UAAU,WAAY;AAAA,MAEtB;AAAA,IACJ,CAAC;AAED,WAAO;AAAA,EACX;;;ACpMO,MAAIC,2BAA0B,SAAU,MAAM;AAEjD,YAAQ,KAAK,SAAS;AAAA,MAClB;AAAA,MACA,KAAK;AAED,eAAO,aAAa,KAAK,GAAG;AAG5B;AAAA,IACR;AAAA,EAOJ;;;AC3BO,MAAM,WAAN,MAAe;AAAA,IAAf;AACH,kBAAO,oBAAI,IAAI;AAEf,0BAAe,SAAU,KAAK;AAC1B,eAAO,IAAI,YAAY;AAAA,MAC3B;AAGA,iBAAM,SAAU,KAAK,MAAM;AAEvB,cAAM,KAAK,aAAa,GAAG;AAG3B,YAAI,OAAO,QAAQ,UAAU;AACzB,iBAAO,KAAK,MAAM,IAAI;AAAA,QAC1B;AAEA,aAAK,KAAK,IAAI,KAAK,IAAI;AAAA,MAC3B;AAEA,qBAAU,SAAU,KAAK;AAErB,cAAM,KAAK,aAAa,GAAG;AAE3B,eAAO,KAAK,KAAK,IAAI,GAAG;AAAA,MAC5B;AACA,2BAAgB,KAAK;AAErB,+BAAoB,SAAU,gBAAgB;AAC1C,eAAO,KAAK,cAAc,cAAc,EAAE;AAAA,MAC9C;AAEA,2BAAgB,SAAU,gBAAgB,UAAU,YAAY;AAC5D,YAAI,OAAO,oBAAI,IAAI;AAEnB,YAAI,KAAK,KAAK,cAAc,cAAc;AAI1C,iBAAS,IAAI,GAAG,IAAI,GAAG,QAAQ,KAC/B;AAEI,eAAK;AAAA,YACD,GAAG,GAAG;AAAA,YACN,GAAG,GAAG;AAAA,UACV;AAAA,QACJ;AAEA,gBAAQ,IAAI,IAAI;AAChB,eAAO;AAAA,MACX;AAEA,kCAAuB,SAAU,gBAAgB,KAAK;AAClD,YAAI,OAAO,oBAAI,IAAI;AAEnB,YAAI,KAAK,KAAK,cAAc,cAAc;AAE1C,mBAAW,KAAK,GAAG,MAAM;AACrB,eAAK;AAAA,YACD;AAAA,YACA,GAAG,KAAK;AAAA,UACZ;AAAA,QACJ;AAEA,eAAO;AAAA,MACX;AAAA;AAAA,EAEJ;;;ACxDO,MAAM,UAAN,MAAc;AAAA,IAMjB,YAAY,MAAmB;AAE3B,WAAK,OAAO;AACZ,WAAK,KAAK;AAAA,IAEd;AAAA,IAEA,OAAO;AAGH,UAAI,KAAK,KAAK,YAAY,UAAU;AAChC,gBAAQ,MAAM,0DAA0D,KAAK,IAAI;AACjF;AAAA,MACJ;AAGA,WAAK,OAAO,KAAK,KAAK,aAAa,MAAM;AACzC,UAAI,KAAK,iEAAiD;AACtD,gBAAQ,MAAM,qCAAqC,KAAK,IAAI;AAC5D;AAAA,MACJ;AAEA,UAAI,OAAO,KAAK,KAAK;AAErB,WAAK,QAAQ,KAAK,MAAM,IAAI;AAAA,IAEhC;AAAA,IAEA,MAAM,SAAmC;AACrC,YAAM,MAAiB,CAAC;AACxB,YAAM,QAAQ,QAAQ,MAAM,IAAI;AAChC,UAAI,aAA4B;AAChC,UAAI,eAA8B;AAClC,UAAI,cAA+C;AACnD,UAAI,mBAAmB;AAEvB,eAAS,QAAQ,OAAO;AACpB,eAAO,KAAK,KAAK;AAGjB,YAAI,CAAC;AAAM;AAGX,YAAI,kBAAkB;AAClB,cAAI,KAAK,SAAS,GAAG,GAAG;AACpB,4BAAgB,OAAO,KAAK,MAAM,GAAG,EAAE;AACvC,gBAAI,eAAe,QAAQ,iBAAiB,MAAM;AAC9C,sBAAQ,aAAa;AAAA,gBACjB,KAAK;AACD,sBAAI,cAAc,WAAW,YAAY;AACzC;AAAA,gBACJ,KAAK;AACD,sBAAI,cAAc,aAAa,YAAY,MAAM;AACjD;AAAA,gBACJ;AACI,sBAAI,cAAc;AAClB;AAAA,cACR;AAAA,YACJ;AACA,+BAAmB;AACnB,2BAAe;AACf,yBAAa;AACb,0BAAc;AAAA,UAClB,OAAO;AACH,4BAAgB,OAAO;AAAA,UAC3B;AACA;AAAA,QACJ;AAEA,cAAM,iBAAiB,KAAK,MAAM,aAAa;AAC/C,YAAI,CAAC;AAAgB;AAErB,cAAM,YAAY,eAAe;AACjC,cAAM,QAAQ,KAAK,MAAM,eAAe,EAAE;AAC1C,cAAM,MAAM,MAAM,GAAG,KAAK;AAC1B,YAAI,QAAQ,MAAM,MAAM,CAAC,EAAE,KAAK,GAAG,EAAE,KAAK;AAG1C,gBAAQ,WAAW;AAAA,UACf,KAAK;AAAA,UACL,KAAK;AACD,0BAAc;AACd;AAAA,UACJ,KAAK;AACD,0BAAc;AACd;AAAA,UACJ,KAAK;AACD,0BAAc;AACd;AAAA,QACR;AAGA,YAAI,MAAM,WAAW,GAAG,GAAG;AACvB,cAAI,MAAM,SAAS,GAAG,GAAG;AACrB,oBAAQ,MAAM,MAAM,GAAG,EAAE;AACzB,oBAAQ,aAAa;AAAA,cACjB,KAAK;AACD,oBAAI,OAAO,WAAW,KAAK;AAC3B;AAAA,cACJ,KAAK;AACD,oBAAI,OAAO,MAAM,YAAY,MAAM;AACnC;AAAA,cACJ;AACI,oBAAI,OAAO;AACX;AAAA,YACR;AAAA,UACJ,OAAO;AACH,+BAAmB;AACnB,yBAAa;AACb,2BAAe,MAAM,MAAM,CAAC;AAAA,UAChC;AAAA,QACJ,OAAO;AACH,kBAAQ,aAAa;AAAA,YACjB,KAAK;AACD,kBAAI,OAAO,WAAW,KAAK;AAC3B;AAAA,YACJ,KAAK;AACD,kBAAI,OAAO,MAAM,YAAY,MAAM;AACnC;AAAA,YACJ;AACI,kBAAI,OAAO;AACX;AAAA,UACR;AAAA,QACJ;AAAA,MACJ;AAEA,aAAO;AAAA,IACX;AAAA,IAEA,OAAO,SAAmC;AACtC,YAAM,MAAiB,CAAC;AACxB,YAAM,QAAQ,QAAQ,MAAM,IAAI;AAChC,UAAI,aAA4B;AAChC,UAAI,eAA8B;AAClC,UAAI,mBAAmB;AAEvB,eAAS,QAAQ,OAAO;AACpB,eAAO,KAAK,KAAK;AAGjB,YAAI,CAAC;AAAM;AAGX,YAAI,kBAAkB;AAClB,cAAI,KAAK,SAAS,GAAG,GAAG;AACpB,4BAAgB,OAAO,KAAK,MAAM,GAAG,EAAE;AACvC,gBAAI,eAAe,QAAQ,iBAAiB,MAAM;AAC9C,kBAAI,cAAc;AAAA,YACtB;AACA,+BAAmB;AACnB,2BAAe;AACf,yBAAa;AAAA,UACjB,OAAO;AACH,4BAAgB,OAAO;AAAA,UAC3B;AACA;AAAA,QACJ;AAEA,cAAM,QAAQ,KAAK,MAAM,GAAG;AAC5B,cAAM,MAAM,MAAM,MAAM,GAAG,KAAK,KAAK;AACrC,cAAM,QAAQ,MAAM,KAAK,GAAG,EAAE,KAAK;AAGnC,YAAI,MAAM,WAAW,GAAG,GAAG;AACvB,cAAI,MAAM,SAAS,GAAG,GAAG;AACrB,gBAAI,OAAO,MAAM,MAAM,GAAG,EAAE;AAAA,UAChC,OAAO;AACH,+BAAmB;AACnB,yBAAa;AACb,2BAAe,MAAM,MAAM,CAAC;AAAA,UAChC;AAAA,QACJ,OAAO;AACH,cAAI,OAAO;AAAA,QACf;AAAA,MACJ;AAEA,aAAO;AAAA,IACX;AAAA,EAEJ;;;AC7IO,MAAM,eAAN,MAAmB;AAAA,IAetB,YAAY,SAAsC,CAAC,GAAG;AAbtD,mBAAuB,CAAC;AAgBpB,WAAK,SAAS;AAAA,QACV,yBAAyB,OAAO;AAAA,QAChC,OAAO,OAAO,SAAS;AAAA,MAC3B;AAAA,IAEJ;AAAA,IAhBQ,0BAA0B,MAAiD;AAE/E,UAAG,CAAC;AAAM,eAAO;AAGjB,aAAO,KAAK,WAAW;AAAA,IAC3B;AAAA,IAYA,OAAO;AAGH,WAAK,SAAS;AAMd,UAAI,OAAgB,QAAQ,QAAQ;AAGpC,YAAM,kBAAkB,KAAK,yDAAgD;AAC7E,UAAI,KAAK,0BAA0B,eAAe,GAAG;AAEjD,aAAK,OAAO,0BAA0B;AAAA,MAE1C;AAGA,UAAI,KAAK,OAAO,yBAAyB;AAErC,aAAK,OAAO,wBAAwB,IAAI;AAAA,MAC5C;AAAA,IAEJ;AAAA,IAEA,aAAa,MAAmB;AAE5B,UAAI,OAAO,KAAK;AAAA,QACZ;AAAA,MAGJ;AAAA,IAEJ;AAAA,IAWA,gBAAgB,MAAyB;AAErC,YAAM,MAAM,KAAK,+CAAuC;AACxD,YAAM,KAAK,KAAK,uDAA2C;AAM3D,UAAI,aAAa,KAAK,MAAM,KAAK,SAAS;AAM1C,UAAI,CAAC,KAAK,MAAM;AACZ,aAAK,MAAM,OAAO,IAAI,SAAS;AAGnC,WAAK,MAAM,KAAK,IAAI,IAAI,UAAU;AAAA,IAEtC;AAAA,IAEA,qBAAqB,MAAyB;AAE1C,YAAM,MAAM,KAAK,+CAAuC;AACxD,YAAM,KAAK,KAAK,uDAA2C;AAE3D,UAAI,IAAI,IAAI,QAAQ,IAAI;AACxB,UAAI,aAAa,EAAE;AAEnB,cAAQ,IAAI,cAAc,UAAU;AAGpC,UAAI,CAAC,KAAK,MAAM;AACZ,aAAK,MAAM,OAAO,IAAI,SAAS;AAGnC,WAAK,MAAM,KAAK,IAAI,IAAI,UAAU;AAAA,IAEtC;AAAA,IAEA,WAAW;AAKP,UAAI,iBAAiB,SAAS;AAAA,QAC1B;AAAA,MACJ;AAGA,qBAAe,QAAQ,CAAC,SAAsB;AAE1C,aAAK,qBAAqB,IAAI;AAAA,MAElC,CAAC;AAGD,UAAI,cAAc,SAAS;AAAA,QACvB;AAAA,MACJ;AAIA,kBAAY,QAAQ,CAAC,SAAsB;AAGvC,aAAK,aAAa,IAAI;AAAA,MAkB1B,CAAC;AAAA,IAGL;AAAA,IAEA,SAAS,MAAc;AAEnB,UAAI,aAAa,SAAS;AAAA,QACtB,mCAA+B;AAAA,MAC/B;AACJ,UAAI,CAAC,YAAY;AACb,gBAAQ,KAAK,gBAAgB,sBAAsB;AACnD;AAAA,MACJ;AAGA,UAAI,iBAAiB,WAAW,iDAAwC;AACxE,cAAQ,IAAI,oBAAoB,gBAAgB;AAEhD,cAAQ,gBAAgB;AAAA,QACpB,KAAK;AACD,iBAAO,gCAAgC,UAAyB;AAAA,QACpE,KAAK;AACD;AAAA,QACJ,KAAK;AACD,iBAAOC;AAAA,YACH,KAAK;AAAA,cACD,WAAW,eAAe;AAAA,YAC9B;AAAA,UACJ;AAAA,QACJ;AACI,kBAAQ,MAAM,sBAAsB,yBAAyB;AAC7D;AAAA,MACR;AAAA,IACJ;AAAA,IAEA,MAAM,OAAO,KAAqC;AAC9C,UAAI,MAAqB;AAEzB,UAAI;AACA,cAAM,WAAW,MAAM,MAAM,GAAG;AAChC,YAAI,SAAS,IAAI;AACb,gBAAM,MAAM,SAAS,KAAK;AAAA,QAC9B,OAAO;AACH,kBAAQ,MAAM,uBAAuB,SAAS,QAAQ;AAAA,QAC1D;AAAA,MACJ,SAAS,OAAP;AACE,gBAAQ,MAAM,uBAAuB,OAAO;AAAA,MAChD;AAEA,aAAO;AAAA,IACX;AAAA,IAEA,UAAU,MAAqB;AAC3B,UAAI,QAAQ;AAQZ,aAAO;AAAA,IACX;AAAA,IAKA,MAAM,aAAa,KAAoC;AACnD,UAAI,OAAqB;AAEzB,UAAI;AACA,cAAM,WAAW,MAAM,MAAM,GAAG;AAChC,YAAI,SAAS,IAAI;AACb,gBAAM,OAAO,MAAM,SAAS,KAAK;AAAA,QAErC,OAAO;AACH,kBAAQ,MAAM,uBAAuB,SAAS,QAAQ;AAAA,QAC1D;AAAA,MACJ,SAAS,OAAP;AACE,gBAAQ,MAAM,uBAAuB,OAAO;AAAA,MAChD;AAEA,aAAO;AAAA,IACX;AAAA,IAEA,yBAAyB,MAAM,UAAU;AACrC,UAAI,OAAO,oBAAI,IAAI;AAEnB,iBAAW,KAAK,KAAK,WAAW;AAC5B,aAAK;AAAA,UACD;AAAA,UACA,KAAK,UAAU;AAAA,QACnB;AAAA,MACJ;AAEA,aAAO;AAAA,IACX;AAAA,EAEJ;",
  "names": ["item", "$", "loadGoogleSheetFromSpec", "loadGoogleSheetFromSpec"]
}
