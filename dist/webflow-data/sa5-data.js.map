{
  "version": 3,
  "sources": ["../../src/webflow-data/sa5-data.ts"],
  "sourcesContent": ["\n/*\n * SA5\n * Sygnal Technology Group\n * sa5-data\n * \n * Creates a data source from SA5 data.\n */\n\n// import { Database } from '../modules/webflow-data.js';\n\nimport { Sa5ScriptType } from '../globals'\n\ntype SA5Object = { [key: string]: any };\n\nexport class Sa5Data {\n\n    elem: HTMLElement;\n    type: string;\n    value: SA5Object;\n\n    constructor(elem: HTMLElement) {\n\n        this.elem = elem; \n        this.init();\n\n    }\n\n    init() {\n\n        // Verify node type\n        if (this.elem.nodeName != \"SCRIPT\") {\n            console.error(\"Invalid element for Sa5Data. Must be a SCRIPT element.\", this.elem);\n            return;\n        }\n        \n        // Verify type\n        this.type = this.elem.getAttribute(\"type\");\n        if (this.type != Sa5ScriptType.SCRIPT_TYPE_SA5_DATA_ITEM) {\n            console.error(\"Invalid element type for Sa5Data.\", this.elem);\n            return; \n        }\n\n        let data = this.elem.innerText;\n\n        this.value = this.parse(data); \n\n    }\n\n    parse(content: string): SA5Object | null {\n        const root: SA5Object = {};\n        const stack: SA5Object[] = [root];\n        const lines = content.split('\\n');\n    \n        let currentKey: string | null = null;\n        let currentType: 'string' | 'number' | 'boolean' = 'string';\n        let currentValue: string | null = null;\n        let isMultiLineValue = false;\n    \n        for (let line of lines) {\n            const indentation = line.search(/\\S/);\n            line = line.trim();\n    \n            // Skip empty lines\n            if (!line) continue;\n    \n            // Adjust the stack based on indentation\n            while (stack.length - 1 > indentation) {\n                stack.pop();\n            }\n    \n            if (isMultiLineValue) {\n                if (line.endsWith('>')) {\n                    currentValue += '\\n' + line.slice(0, -1); // Exclude the closing '>'\n                    if (currentKey !== null && currentValue !== null) {\n                        stack[stack.length - 1][currentKey] = currentValue || null;\n                    }\n                    isMultiLineValue = false;\n                    currentValue = null;\n                    currentKey = null;\n                    currentType = 'string';\n                    continue;\n                } else {\n                    currentValue += '\\n' + line;\n                    continue;\n                }\n            }\n    \n            const delimiterMatch = line.match(/:(\\$|#|\\?|:|)/);\n            if (!delimiterMatch) continue;\n    \n            const delimiter = delimiterMatch[1];\n            const parts = line.split(delimiterMatch[0]);\n            const key = parts[0].trim();\n            let value: any = parts.slice(1).join(':').trim();\n    \n            // Determine the type based on the delimiter\n            switch (delimiter) {\n                case '':\n                case '$':\n                    if (value.startsWith('<') && !value.endsWith('>')) {\n                        isMultiLineValue = true;\n                        currentKey = key;\n                        currentValue = value.slice(1); // Exclude the starting '<'\n                        continue;\n                    } else if (value.startsWith('<') && value.endsWith('>')) {\n                        value = value.slice(1, -1); // Exclude both the starting '<' and closing '>'\n                    }\n                    value = value || null;\n                    break;\n                case '#':\n                    value = value ? parseFloat(value) : null;\n                    break;\n                case '?':\n                    value = value ? value.toLowerCase() === 'true' : null;\n                    break;\n                case ':': // Nested object\n                    const newObj: SA5Object = {};\n                    stack[stack.length - 1][key] = newObj;\n                    stack.push(newObj);\n                    continue; // Skip further processing for this line since it's a nested object indicator\n            }\n    \n            stack[stack.length - 1][key] = value;\n        }\n    \n        return root;\n    }\n\n}\n\n\n\n"],
  "mappings": ";;AAeO,MAAM,UAAN,MAAc;AAAA,IAMjB,YAAY,MAAmB;AAE3B,WAAK,OAAO;AACZ,WAAK,KAAK;AAAA,IAEd;AAAA,IAEA,OAAO;AAGH,UAAI,KAAK,KAAK,YAAY,UAAU;AAChC,gBAAQ,MAAM,0DAA0D,KAAK,IAAI;AACjF;AAAA,MACJ;AAGA,WAAK,OAAO,KAAK,KAAK,aAAa,MAAM;AACzC,UAAI,KAAK,iEAAiD;AACtD,gBAAQ,MAAM,qCAAqC,KAAK,IAAI;AAC5D;AAAA,MACJ;AAEA,UAAI,OAAO,KAAK,KAAK;AAErB,WAAK,QAAQ,KAAK,MAAM,IAAI;AAAA,IAEhC;AAAA,IAEA,MAAM,SAAmC;AACrC,YAAM,OAAkB,CAAC;AACzB,YAAM,QAAqB,CAAC,IAAI;AAChC,YAAM,QAAQ,QAAQ,MAAM,IAAI;AAEhC,UAAI,aAA4B;AAChC,UAAI,cAA+C;AACnD,UAAI,eAA8B;AAClC,UAAI,mBAAmB;AAEvB,eAAS,QAAQ,OAAO;AACpB,cAAM,cAAc,KAAK,OAAO,IAAI;AACpC,eAAO,KAAK,KAAK;AAGjB,YAAI,CAAC;AAAM;AAGX,eAAO,MAAM,SAAS,IAAI,aAAa;AACnC,gBAAM,IAAI;AAAA,QACd;AAEA,YAAI,kBAAkB;AAClB,cAAI,KAAK,SAAS,GAAG,GAAG;AACpB,4BAAgB,OAAO,KAAK,MAAM,GAAG,EAAE;AACvC,gBAAI,eAAe,QAAQ,iBAAiB,MAAM;AAC9C,oBAAM,MAAM,SAAS,GAAG,cAAc,gBAAgB;AAAA,YAC1D;AACA,+BAAmB;AACnB,2BAAe;AACf,yBAAa;AACb,0BAAc;AACd;AAAA,UACJ,OAAO;AACH,4BAAgB,OAAO;AACvB;AAAA,UACJ;AAAA,QACJ;AAEA,cAAM,iBAAiB,KAAK,MAAM,eAAe;AACjD,YAAI,CAAC;AAAgB;AAErB,cAAM,YAAY,eAAe;AACjC,cAAM,QAAQ,KAAK,MAAM,eAAe,EAAE;AAC1C,cAAM,MAAM,MAAM,GAAG,KAAK;AAC1B,YAAI,QAAa,MAAM,MAAM,CAAC,EAAE,KAAK,GAAG,EAAE,KAAK;AAG/C,gBAAQ,WAAW;AAAA,UACf,KAAK;AAAA,UACL,KAAK;AACD,gBAAI,MAAM,WAAW,GAAG,KAAK,CAAC,MAAM,SAAS,GAAG,GAAG;AAC/C,iCAAmB;AACnB,2BAAa;AACb,6BAAe,MAAM,MAAM,CAAC;AAC5B;AAAA,YACJ,WAAW,MAAM,WAAW,GAAG,KAAK,MAAM,SAAS,GAAG,GAAG;AACrD,sBAAQ,MAAM,MAAM,GAAG,EAAE;AAAA,YAC7B;AACA,oBAAQ,SAAS;AACjB;AAAA,UACJ,KAAK;AACD,oBAAQ,QAAQ,WAAW,KAAK,IAAI;AACpC;AAAA,UACJ,KAAK;AACD,oBAAQ,QAAQ,MAAM,YAAY,MAAM,SAAS;AACjD;AAAA,UACJ,KAAK;AACD,kBAAM,SAAoB,CAAC;AAC3B,kBAAM,MAAM,SAAS,GAAG,OAAO;AAC/B,kBAAM,KAAK,MAAM;AACjB;AAAA,QACR;AAEA,cAAM,MAAM,SAAS,GAAG,OAAO;AAAA,MACnC;AAEA,aAAO;AAAA,IACX;AAAA,EAEJ;",
  "names": []
}
